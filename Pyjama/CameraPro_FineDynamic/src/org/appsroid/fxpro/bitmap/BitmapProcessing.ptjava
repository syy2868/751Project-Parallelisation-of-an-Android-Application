/*
*  Copyright (C) 2013 Dept. of ECE, UoA, New Zealand
*
*  This is automatically generated file from Pyjama compiler.
* 
*  Pyjama is free software: you can redistribute it and/or modify
*  it under the terms of the GNU General Public License as published by
*  the Free Software Foundation, either version 3 of the License, or (at
*  your option) any later version.
*
*  Pyjama is distributed in the hope that it will be useful,
*  but WITHOUT ANY WARRANTY; without even the implied warranty of
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
*  Public License for more details.
*
*  You should have received a copy of the GNU General Public License along
*  with Pyjama. If not, see <http://www.gnu.org/licenses/>.
*/
package org.appsroid.fxpro.bitmap;

import java.util.ArrayList;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import pj.parser.ast.visitor.DummyClassToDetermineVariableType;
import pt.runtime.*;
import pj.Pyjama;
import pj.PJPackageOnly;
import pj.UniqueThreadIdGeneratorForOpenMP;
import pi.ParIteratorFactory;
import pi.ParIterator;
import pi.reductions.Reducible;
import pi.reductions.Reduction;
import java.util.concurrent.atomic.*;
import java.util.concurrent.*;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import pj.parser.ast.visitor.DummyClassToDetermineVariableType;
import java.io.IOException;
import java.util.Random;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.ColorFilter;
import android.graphics.ColorMatrix;
import android.graphics.ColorMatrixColorFilter;
import android.graphics.LightingColorFilter;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.graphics.PorterDuff;
import android.graphics.PorterDuffXfermode;
import android.graphics.RadialGradient;
import android.graphics.Rect;
import android.graphics.RectF;
import android.graphics.Shader;
import android.media.ExifInterface;

import pi.reductions.Reducible;
import java.util.*;
public class BitmapProcessing {
    /* initialise the runtime */
    static {
        try{
            Pyjama.init();
        }catch(Exception e){
        }
    }
    static private ArrayList<ParIterator<?>> _omp_piVarContainer = new ArrayList<ParIterator<?>>();
    static private AtomicBoolean _holderForPIFirst;
    /* initialize the main handler for gui constructs */
    Handler _omp_android_mainLoopHandler = new Handler(Looper.getMainLooper());
    public static Bitmap rotate(Bitmap bitmap, float degrees) {{
        Matrix matrix = new Matrix();
        matrix.postRotate(degrees);
        return Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true);
    }
    }
    
    public static Bitmap flip(Bitmap bitmap, boolean horizontal, boolean vertical) {{
        Matrix matrix = new Matrix();
        matrix.preScale(horizontal ? -1 : 1, vertical ? -1 : 1);
        return Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true);
    }
    }
    
    public static Bitmap emboss(Bitmap src) {{
        double[][] EmbossConfig = new double[][] { { -1, 0, -1 }, { 0, 4, 0 }, { -1, 0, -1 } };
        ConvolutionMatrix convMatrix = new ConvolutionMatrix(3);
        convMatrix.applyConfig(EmbossConfig);
        convMatrix.Factor = 1;
        convMatrix.Offset = 127;
        return ConvolutionMatrix.computeConvolution3x3(src, convMatrix);
    }
    }
    
    public static Bitmap cfilter(Bitmap src, double red, double green, double blue) {{
        red = (double) red / 100;
        green = (double) green / 100;
        blue = (double) blue / 100;
        int width = src.getWidth();
        int height = src.getHeight();
        Bitmap bmOut = Bitmap.createBitmap(width, height, src.getConfig());
        int A = 0, R = 0, G = 0, B = 0;
        int pixel = 0;
        /*OpenMP Parallel region (#0) -- START */
        if(Pyjama.insideParallelRegion() ) {
            /* If already inside a parallel region, execute sequentially (nested parallelism currently not supported) */
            {
                for (int x = 0; x < width; x = x+1) {
                    for (int y = 0; y < height; ++y) {
                        pixel = src.getPixel(x, y);
                        A = Color.alpha(pixel);
                        R = (int) (Color.red(pixel) * red);
                        G = (int) (Color.green(pixel) * green);
                        B = (int) (Color.blue(pixel) * blue);
                        bmOut.setPixel(x, y, Color.argb(A, R, G, B));
                    }
                }
            }
        } else {
            /* Else, execute in parallel */
            PJPackageOnly.setThreadCountCurrentParallelRegion(Pyjama.omp_get_num_threads());

            /* Process data clauses */
            _omp__parallelRegionVarHolderClass_BitmapProcessing0 _omp__parallelRegionVarHolderInstance_0 = new _omp__parallelRegionVarHolderClass_BitmapProcessing0();
            _omp__parallelRegionVarHolderInstance_0.bmOut = bmOut; // auto-saving
            _omp__parallelRegionVarHolderInstance_0.G = G; // auto-saving
            _omp__parallelRegionVarHolderInstance_0.height = height; // auto-saving
            _omp__parallelRegionVarHolderInstance_0.red = red; // auto-saving
            _omp__parallelRegionVarHolderInstance_0.pixel = pixel; // auto-saving
            _omp__parallelRegionVarHolderInstance_0.A = A; // auto-saving
            _omp__parallelRegionVarHolderInstance_0.blue = blue; // auto-saving
            _omp__parallelRegionVarHolderInstance_0.B = B; // auto-saving
            _omp__parallelRegionVarHolderInstance_0.green = green; // auto-saving
            _omp__parallelRegionVarHolderInstance_0.R = R; // auto-saving
            _omp__parallelRegionVarHolderInstance_0.width = width; // auto-saving
            _omp__parallelRegionVarHolderInstance_0.src = src; // auto-saving

            /* Execute using traditional OpenMP (master thread part of the team) */
            PJPackageOnly.setMasterThread(Thread.currentThread());
            TaskID _omp__parallelRegionTaskID_0 = _ompParallelRegion_0(_omp__parallelRegionVarHolderInstance_0);
            __pt___ompParallelRegion_0(_omp__parallelRegionVarHolderInstance_0);
            try {_omp__parallelRegionTaskID_0.waitTillFinished();} catch(Exception __pt__ex) { __pt__ex.printStackTrace(); }
            
            PJPackageOnly.setMasterThread(null);
            _holderForPIFirst.set(true);
//#GEN#[-1]#PJ#
            bmOut=_omp__parallelRegionVarHolderInstance_0.bmOut; // auto-saved//#GEN#[-1]#PJ#
            G=_omp__parallelRegionVarHolderInstance_0.G; // auto-saved//#GEN#[-1]#PJ#
            height=_omp__parallelRegionVarHolderInstance_0.height; // auto-saved//#GEN#[-1]#PJ#
            red=_omp__parallelRegionVarHolderInstance_0.red; // auto-saved//#GEN#[-1]#PJ#
            pixel=_omp__parallelRegionVarHolderInstance_0.pixel; // auto-saved//#GEN#[-1]#PJ#
            A=_omp__parallelRegionVarHolderInstance_0.A; // auto-saved//#GEN#[-1]#PJ#
            blue=_omp__parallelRegionVarHolderInstance_0.blue; // auto-saved//#GEN#[-1]#PJ#
            B=_omp__parallelRegionVarHolderInstance_0.B; // auto-saved//#GEN#[-1]#PJ#
            green=_omp__parallelRegionVarHolderInstance_0.green; // auto-saved//#GEN#[-1]#PJ#
            R=_omp__parallelRegionVarHolderInstance_0.R; // auto-saved//#GEN#[-1]#PJ#
            width=_omp__parallelRegionVarHolderInstance_0.width; // auto-saved//#GEN#[-1]#PJ#
            src=_omp__parallelRegionVarHolderInstance_0.src; // auto-saved//#GEN#[-1]#PJ#
            PJPackageOnly.setThreadCountCurrentParallelRegion(1);
        }
        /*OpenMP Parallel region (#0) -- END */

        src.recycle();
        src = null;
        return bmOut;
    }
    }
        static private AtomicBoolean _imFirst_2 = new AtomicBoolean(true);
    static private AtomicInteger _imFinishedCounter_2 = new AtomicInteger(0);
    static private CountDownLatch _waitBarrier_2 = new CountDownLatch(1);
    static private CountDownLatch _waitBarrierAfter_2 = new CountDownLatch(1);
    static private ParIterator<Integer> _pi_2 = null;
    static private Integer _lastElement_2 = null;
    static private _ompWorkSharedUserCode_BitmapProcessing2_variables _ompWorkSharedUserCode_BitmapProcessing2_variables_instance = null;
        static private void _ompWorkSharedUserCode_BitmapProcessing2(_ompWorkSharedUserCode_BitmapProcessing2_variables __omp_vars) {
//#GEN#[-1]#PJ#
        int width = __omp_vars.width; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int height = __omp_vars.height; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int A = __omp_vars.A; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int R = __omp_vars.R; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int G = __omp_vars.G; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int B = __omp_vars.B; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int pixel = __omp_vars.pixel; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        double red = __omp_vars.red; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        double green = __omp_vars.green; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        double blue = __omp_vars.blue; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        Bitmap bmOut = __omp_vars.bmOut; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        Bitmap src = __omp_vars.src; // Auto-saved//#GEN#[-1]#PJ#
        Integer x;
        while (_pi_2.hasNext()) {
            x = _pi_2.next();
            
            {
                for (int y = 0; y < height; ++y) {
                    pixel = src.getPixel(x, y);
                    A = Color.alpha(pixel);
                    R = (int) (Color.red(pixel) * red);
                    G = (int) (Color.green(pixel) * green);
                    B = (int) (Color.blue(pixel) * blue);
                    bmOut.setPixel(x, y, Color.argb(A, R, G, B));
                }
            }
        }
//#GEN#[-1]#PJ#
    __omp_vars.src = src; // Re-collected//#GEN#[-1]#PJ#
    }
    
    
    /* Parallel region, placed in a multi-task */
    TASK(Pyjama.omp_get_num_threads()-1) private static void _ompParallelRegion_0(_omp__parallelRegionVarHolderClass_BitmapProcessing0 __omp_vars) {
//#GEN#[-1]#PJ#
        Bitmap bmOut = __omp_vars.bmOut; // Auto-saved//#GEN#[-1]#PJ#
        int G = __omp_vars.G; // Auto-saved//#GEN#[-1]#PJ#
        int height = __omp_vars.height; // Auto-saved//#GEN#[-1]#PJ#
        double red = __omp_vars.red; // Auto-saved//#GEN#[-1]#PJ#
        int pixel = __omp_vars.pixel; // Auto-saved//#GEN#[-1]#PJ#
        int A = __omp_vars.A; // Auto-saved//#GEN#[-1]#PJ#
        double blue = __omp_vars.blue; // Auto-saved//#GEN#[-1]#PJ#
        int B = __omp_vars.B; // Auto-saved//#GEN#[-1]#PJ#
        double green = __omp_vars.green; // Auto-saved//#GEN#[-1]#PJ#
        int R = __omp_vars.R; // Auto-saved//#GEN#[-1]#PJ#
        int width = __omp_vars.width; // Auto-saved//#GEN#[-1]#PJ#
        Bitmap src = __omp_vars.src; // Auto-saved//#GEN#[-1]#PJ#
        {
            if ( Pyjama.insideParallelRegion() ) {
                /* Share the following work-sharing construct amongst multiple threads only if inside a parallel region (need this check for orphaned work-sharing constructs) */
                boolean _omp_imFirst = _imFirst_2.getAndSet(false);
                _holderForPIFirst = _imFirst_2;
                if (_omp_imFirst) {
                    _ompWorkSharedUserCode_BitmapProcessing2_variables_instance = new _ompWorkSharedUserCode_BitmapProcessing2_variables();
                    int __omp_size_ = 0;
                    // TODO -- improve performance by calculating N from the parameters (as an equation) rather than looping
                    for (int x = 0; x < width; x = x+1) {
                        _lastElement_2 = x;
                        __omp_size_++;
                        }
                    _pi_2 = ParIteratorFactory.createParIterator(0, __omp_size_, 1, Pyjama.omp_get_num_threads(), ParIterator.Schedule.DYNAMIC, 10, false);
                    _omp_piVarContainer.add(_pi_2); // for interrupt statement
                    _pi_2.setThreadIdGenerator(new UniqueThreadIdGeneratorForOpenMP());//#GEN#[-1]#PJ#
//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing2_variables_instance.width = width; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing2_variables_instance.height = height; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing2_variables_instance.A = A; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing2_variables_instance.R = R; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing2_variables_instance.G = G; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing2_variables_instance.B = B; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing2_variables_instance.pixel = pixel; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing2_variables_instance.red = red; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing2_variables_instance.green = green; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing2_variables_instance.blue = blue; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing2_variables_instance.bmOut = bmOut; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing2_variables_instance.src = src; // auto-saving
                    _waitBarrier_2.countDown();
                } else {
                    try { _waitBarrier_2.await(); } catch (InterruptedException __omp__ie) { __omp__ie.printStackTrace(); }
                }
                _ompWorkSharedUserCode_BitmapProcessing2(_ompWorkSharedUserCode_BitmapProcessing2_variables_instance);
                if (_imFinishedCounter_2.incrementAndGet() == PJPackageOnly.getThreadCountCurrentParallelRegion()) {
                    _waitBarrierAfter_2.countDown();
                } else {
                    try { 
                        _waitBarrierAfter_2.await();
                    } catch (InterruptedException __omp__ie) { 
                        __omp__ie.printStackTrace(); 
                    }
                }
                // TODO: recollect
//#GEN#[-1]#PJ#
            } else {
                /* Otherwise, this orphaned work-sharing is not within a parallel region.. so execute sequentially */
                for (int x = 0; x < width; x = x+1) {
                    for (int y = 0; y < __omp_vars.height; ++y) {
                        __omp_vars.pixel = __omp_vars.src.getPixel(x, y);
                        __omp_vars.A = Color.alpha(__omp_vars.pixel);
                        __omp_vars.R = (int) (Color.red(__omp_vars.pixel) * __omp_vars.red);
                        __omp_vars.G = (int) (Color.green(__omp_vars.pixel) * __omp_vars.green);
                        __omp_vars.B = (int) (Color.blue(__omp_vars.pixel) * __omp_vars.blue);
                        __omp_vars.bmOut.setPixel(x, y, Color.argb(__omp_vars.A, __omp_vars.R, __omp_vars.G, __omp_vars.B));
                    }
                }
            }

        }
//#GEN#[-1]#PJ#
        __omp_vars.bmOut = bmOut; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.G = G; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.height = height; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.red = red; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.pixel = pixel; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.A = A; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.blue = blue; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.B = B; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.green = green; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.R = R; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.width = width; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.src = src; // restore auto-saved variable//#GEN#[-1]#PJ#
    }
    public static Bitmap gaussian(Bitmap src) {{
        double[][] GaussianBlurConfig = new double[][] { { 1, 2, 1 }, { 2, 4, 2 }, { 1, 2, 1 } };
        ConvolutionMatrix convMatrix = new ConvolutionMatrix(3);
        convMatrix.applyConfig(GaussianBlurConfig);
        convMatrix.Factor = 16;
        convMatrix.Offset = 0;
        return ConvolutionMatrix.computeConvolution3x3(src, convMatrix);
    }
    }
    
    public static Bitmap cdepth(Bitmap src, int bitOffset) {{
        int width = src.getWidth();
        int height = src.getHeight();
        Bitmap bmOut = Bitmap.createBitmap(width, height, src.getConfig());
        int A = 0, R = 0, G = 0, B = 0;
        int pixel = 0;
        /*OpenMP Parallel region (#3) -- START */
        if(Pyjama.insideParallelRegion() ) {
            /* If already inside a parallel region, execute sequentially (nested parallelism currently not supported) */
            {
                for (int x = 0; x < width; x = x+1) {
                    for (int y = 0; y < height; ++y) {
                        pixel = src.getPixel(x, y);
                        A = Color.alpha(pixel);
                        R = Color.red(pixel);
                        G = Color.green(pixel);
                        B = Color.blue(pixel);
                        R = ((R + (bitOffset / 2)) - ((R + (bitOffset / 2)) % bitOffset) - 1);
                        if (R < 0) {
                            R = 0;
                        }
                        G = ((G + (bitOffset / 2)) - ((G + (bitOffset / 2)) % bitOffset) - 1);
                        if (G < 0) {
                            G = 0;
                        }
                        B = ((B + (bitOffset / 2)) - ((B + (bitOffset / 2)) % bitOffset) - 1);
                        if (B < 0) {
                            B = 0;
                        }
                        bmOut.setPixel(x, y, Color.argb(A, R, G, B));
                    }
                }
            }
        } else {
            /* Else, execute in parallel */
            PJPackageOnly.setThreadCountCurrentParallelRegion(Pyjama.omp_get_num_threads());

            /* Process data clauses */
            _omp__parallelRegionVarHolderClass_BitmapProcessing3 _omp__parallelRegionVarHolderInstance_3 = new _omp__parallelRegionVarHolderClass_BitmapProcessing3();
            _omp__parallelRegionVarHolderInstance_3.bmOut = bmOut; // auto-saving
            _omp__parallelRegionVarHolderInstance_3.G = G; // auto-saving
            _omp__parallelRegionVarHolderInstance_3.height = height; // auto-saving
            _omp__parallelRegionVarHolderInstance_3.pixel = pixel; // auto-saving
            _omp__parallelRegionVarHolderInstance_3.A = A; // auto-saving
            _omp__parallelRegionVarHolderInstance_3.B = B; // auto-saving
            _omp__parallelRegionVarHolderInstance_3.R = R; // auto-saving
            _omp__parallelRegionVarHolderInstance_3.width = width; // auto-saving
            _omp__parallelRegionVarHolderInstance_3.bitOffset = bitOffset; // auto-saving
            _omp__parallelRegionVarHolderInstance_3.src = src; // auto-saving

            /* Execute using traditional OpenMP (master thread part of the team) */
            PJPackageOnly.setMasterThread(Thread.currentThread());
            TaskID _omp__parallelRegionTaskID_3 = _ompParallelRegion_3(_omp__parallelRegionVarHolderInstance_3);
            __pt___ompParallelRegion_3(_omp__parallelRegionVarHolderInstance_3);
            try {_omp__parallelRegionTaskID_3.waitTillFinished();} catch(Exception __pt__ex) { __pt__ex.printStackTrace(); }
            
            PJPackageOnly.setMasterThread(null);
            _holderForPIFirst.set(true);
//#GEN#[-1]#PJ#
            bmOut=_omp__parallelRegionVarHolderInstance_3.bmOut; // auto-saved//#GEN#[-1]#PJ#
            G=_omp__parallelRegionVarHolderInstance_3.G; // auto-saved//#GEN#[-1]#PJ#
            height=_omp__parallelRegionVarHolderInstance_3.height; // auto-saved//#GEN#[-1]#PJ#
            pixel=_omp__parallelRegionVarHolderInstance_3.pixel; // auto-saved//#GEN#[-1]#PJ#
            A=_omp__parallelRegionVarHolderInstance_3.A; // auto-saved//#GEN#[-1]#PJ#
            B=_omp__parallelRegionVarHolderInstance_3.B; // auto-saved//#GEN#[-1]#PJ#
            R=_omp__parallelRegionVarHolderInstance_3.R; // auto-saved//#GEN#[-1]#PJ#
            width=_omp__parallelRegionVarHolderInstance_3.width; // auto-saved//#GEN#[-1]#PJ#
            bitOffset=_omp__parallelRegionVarHolderInstance_3.bitOffset; // auto-saved//#GEN#[-1]#PJ#
            src=_omp__parallelRegionVarHolderInstance_3.src; // auto-saved//#GEN#[-1]#PJ#
            PJPackageOnly.setThreadCountCurrentParallelRegion(1);
        }
        /*OpenMP Parallel region (#3) -- END */

        src.recycle();
        src = null;
        return bmOut;
    }
    }
    static private AtomicBoolean _imFirst_5 = new AtomicBoolean(true);
    static private AtomicInteger _imFinishedCounter_5 = new AtomicInteger(0);
    static private CountDownLatch _waitBarrier_5 = new CountDownLatch(1);
    static private CountDownLatch _waitBarrierAfter_5 = new CountDownLatch(1);
    static private ParIterator<Integer> _pi_5 = null;
    static private Integer _lastElement_5 = null;
    static private _ompWorkSharedUserCode_BitmapProcessing5_variables _ompWorkSharedUserCode_BitmapProcessing5_variables_instance = null;
        static private void _ompWorkSharedUserCode_BitmapProcessing5(_ompWorkSharedUserCode_BitmapProcessing5_variables __omp_vars) {
//#GEN#[-1]#PJ#
        int width = __omp_vars.width; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int height = __omp_vars.height; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int A = __omp_vars.A; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int R = __omp_vars.R; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int G = __omp_vars.G; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int B = __omp_vars.B; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int pixel = __omp_vars.pixel; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int bitOffset = __omp_vars.bitOffset; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        Bitmap bmOut = __omp_vars.bmOut; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        Bitmap src = __omp_vars.src; // Auto-saved//#GEN#[-1]#PJ#
        Integer x;
        while (_pi_5.hasNext()) {
            x = _pi_5.next();
            
            {
                for (int y = 0; y < height; ++y) {
                    pixel = src.getPixel(x, y);
                    A = Color.alpha(pixel);
                    R = Color.red(pixel);
                    G = Color.green(pixel);
                    B = Color.blue(pixel);
                    R = ((R + (bitOffset / 2)) - ((R + (bitOffset / 2)) % bitOffset) - 1);
                    if (R < 0) {
                        R = 0;
                    }
                    G = ((G + (bitOffset / 2)) - ((G + (bitOffset / 2)) % bitOffset) - 1);
                    if (G < 0) {
                        G = 0;
                    }
                    B = ((B + (bitOffset / 2)) - ((B + (bitOffset / 2)) % bitOffset) - 1);
                    if (B < 0) {
                        B = 0;
                    }
                    bmOut.setPixel(x, y, Color.argb(A, R, G, B));
                }
            }
        }
//#GEN#[-1]#PJ#
    __omp_vars.src = src; // Re-collected//#GEN#[-1]#PJ#
    }
    
    
    /* Parallel region, placed in a multi-task */
    TASK(Pyjama.omp_get_num_threads()-1) private static void _ompParallelRegion_3(_omp__parallelRegionVarHolderClass_BitmapProcessing3 __omp_vars) {
//#GEN#[-1]#PJ#
        Bitmap bmOut = __omp_vars.bmOut; // Auto-saved//#GEN#[-1]#PJ#
        int G = __omp_vars.G; // Auto-saved//#GEN#[-1]#PJ#
        int height = __omp_vars.height; // Auto-saved//#GEN#[-1]#PJ#
        int pixel = __omp_vars.pixel; // Auto-saved//#GEN#[-1]#PJ#
        int A = __omp_vars.A; // Auto-saved//#GEN#[-1]#PJ#
        int B = __omp_vars.B; // Auto-saved//#GEN#[-1]#PJ#
        int R = __omp_vars.R; // Auto-saved//#GEN#[-1]#PJ#
        int width = __omp_vars.width; // Auto-saved//#GEN#[-1]#PJ#
        int bitOffset = __omp_vars.bitOffset; // Auto-saved//#GEN#[-1]#PJ#
        Bitmap src = __omp_vars.src; // Auto-saved//#GEN#[-1]#PJ#
        {
            if ( Pyjama.insideParallelRegion() ) {
                /* Share the following work-sharing construct amongst multiple threads only if inside a parallel region (need this check for orphaned work-sharing constructs) */
                boolean _omp_imFirst = _imFirst_5.getAndSet(false);
                _holderForPIFirst = _imFirst_5;
                if (_omp_imFirst) {
                    _ompWorkSharedUserCode_BitmapProcessing5_variables_instance = new _ompWorkSharedUserCode_BitmapProcessing5_variables();
                    int __omp_size_ = 0;
                    // TODO -- improve performance by calculating N from the parameters (as an equation) rather than looping
                    for (int x = 0; x < width; x = x+1) {
                        _lastElement_5 = x;
                        __omp_size_++;
                        }
                    _pi_5 = ParIteratorFactory.createParIterator(0, __omp_size_, 1, Pyjama.omp_get_num_threads(), ParIterator.Schedule.DYNAMIC, 10, false);
                    _omp_piVarContainer.add(_pi_5); // for interrupt statement
                    _pi_5.setThreadIdGenerator(new UniqueThreadIdGeneratorForOpenMP());//#GEN#[-1]#PJ#
//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing5_variables_instance.width = width; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing5_variables_instance.height = height; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing5_variables_instance.A = A; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing5_variables_instance.R = R; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing5_variables_instance.G = G; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing5_variables_instance.B = B; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing5_variables_instance.pixel = pixel; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing5_variables_instance.bitOffset = bitOffset; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing5_variables_instance.bmOut = bmOut; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing5_variables_instance.src = src; // auto-saving
                    _waitBarrier_5.countDown();
                } else {
                    try { _waitBarrier_5.await(); } catch (InterruptedException __omp__ie) { __omp__ie.printStackTrace(); }
                }
                _ompWorkSharedUserCode_BitmapProcessing5(_ompWorkSharedUserCode_BitmapProcessing5_variables_instance);
                if (_imFinishedCounter_5.incrementAndGet() == PJPackageOnly.getThreadCountCurrentParallelRegion()) {
                    _waitBarrierAfter_5.countDown();
                } else {
                    try { 
                        _waitBarrierAfter_5.await();
                    } catch (InterruptedException __omp__ie) { 
                        __omp__ie.printStackTrace(); 
                    }
                }
                // TODO: recollect
//#GEN#[-1]#PJ#
            } else {
                /* Otherwise, this orphaned work-sharing is not within a parallel region.. so execute sequentially */
                for (int x = 0; x < width; x = x+1) {
                    for (int y = 0; y < __omp_vars.height; ++y) {
                        __omp_vars.pixel = __omp_vars.src.getPixel(x, y);
                        __omp_vars.A = Color.alpha(__omp_vars.pixel);
                        __omp_vars.R = Color.red(__omp_vars.pixel);
                        __omp_vars.G = Color.green(__omp_vars.pixel);
                        __omp_vars.B = Color.blue(__omp_vars.pixel);
                        __omp_vars.R = ((__omp_vars.R + (__omp_vars.bitOffset / 2)) - ((__omp_vars.R + (__omp_vars.bitOffset / 2)) % __omp_vars.bitOffset) - 1);
                        if (__omp_vars.R < 0) {
                            __omp_vars.R = 0;
                        }
                        __omp_vars.G = ((__omp_vars.G + (__omp_vars.bitOffset / 2)) - ((__omp_vars.G + (__omp_vars.bitOffset / 2)) % __omp_vars.bitOffset) - 1);
                        if (__omp_vars.G < 0) {
                            __omp_vars.G = 0;
                        }
                        __omp_vars.B = ((__omp_vars.B + (__omp_vars.bitOffset / 2)) - ((__omp_vars.B + (__omp_vars.bitOffset / 2)) % __omp_vars.bitOffset) - 1);
                        if (__omp_vars.B < 0) {
                            __omp_vars.B = 0;
                        }
                        __omp_vars.bmOut.setPixel(x, y, Color.argb(__omp_vars.A, __omp_vars.R, __omp_vars.G, __omp_vars.B));
                    }
                }
            }

        }
//#GEN#[-1]#PJ#
        __omp_vars.bmOut = bmOut; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.G = G; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.height = height; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.pixel = pixel; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.A = A; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.B = B; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.R = R; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.width = width; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.bitOffset = bitOffset; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.src = src; // restore auto-saved variable//#GEN#[-1]#PJ#
    }
    public static Bitmap sharpen(Bitmap src) {{
        double[][] SharpConfig = new double[][] { { 0, -2, 0 }, { -2, 11, -2 }, { 0, -2, 0 } };
        ConvolutionMatrix convMatrix = new ConvolutionMatrix(3);
        convMatrix.applyConfig(SharpConfig);
        convMatrix.Factor = 3;
        return ConvolutionMatrix.computeConvolution3x3(src, convMatrix);
    }
    }
    
    public static Bitmap noise(Bitmap source) {{
        int COLOR_MAX = 0xFF;
        int width = source.getWidth();
        int height = source.getHeight();
        int[] pixels = new int[width * height];
        source.getPixels(pixels, 0, width, 0, 0, width, height);
        Random random = new Random();
        int index = 0;
        /*OpenMP Parallel region (#6) -- START */
        if(Pyjama.insideParallelRegion() ) {
            /* If already inside a parallel region, execute sequentially (nested parallelism currently not supported) */
            {
                for (int y = 0; y < height; y = y+1) {
                    for (int x = 0; x < width; ++x) {
                        index = y * width + x;
                        int randColor = Color.rgb(random.nextInt(COLOR_MAX), random.nextInt(COLOR_MAX), random.nextInt(COLOR_MAX));
                        pixels[index] |= randColor;
                    }
                }
            }
        } else {
            /* Else, execute in parallel */
            PJPackageOnly.setThreadCountCurrentParallelRegion(Pyjama.omp_get_num_threads());

            /* Process data clauses */
            _omp__parallelRegionVarHolderClass_BitmapProcessing6 _omp__parallelRegionVarHolderInstance_6 = new _omp__parallelRegionVarHolderClass_BitmapProcessing6();
            _omp__parallelRegionVarHolderInstance_6.index = index; // auto-saving
            _omp__parallelRegionVarHolderInstance_6.height = height; // auto-saving
            _omp__parallelRegionVarHolderInstance_6.source = source; // auto-saving
            _omp__parallelRegionVarHolderInstance_6.COLOR_MAX = COLOR_MAX; // auto-saving
            _omp__parallelRegionVarHolderInstance_6.width = width; // auto-saving
            _omp__parallelRegionVarHolderInstance_6.random = random; // auto-saving
            _omp__parallelRegionVarHolderInstance_6.pixels = pixels; // auto-saving

            /* Execute using traditional OpenMP (master thread part of the team) */
            PJPackageOnly.setMasterThread(Thread.currentThread());
            TaskID _omp__parallelRegionTaskID_6 = _ompParallelRegion_6(_omp__parallelRegionVarHolderInstance_6);
            __pt___ompParallelRegion_6(_omp__parallelRegionVarHolderInstance_6);
            try {_omp__parallelRegionTaskID_6.waitTillFinished();} catch(Exception __pt__ex) { __pt__ex.printStackTrace(); }
            
            PJPackageOnly.setMasterThread(null);
            _holderForPIFirst.set(true);
//#GEN#[-1]#PJ#
            index=_omp__parallelRegionVarHolderInstance_6.index; // auto-saved//#GEN#[-1]#PJ#
            height=_omp__parallelRegionVarHolderInstance_6.height; // auto-saved//#GEN#[-1]#PJ#
            source=_omp__parallelRegionVarHolderInstance_6.source; // auto-saved//#GEN#[-1]#PJ#
            COLOR_MAX=_omp__parallelRegionVarHolderInstance_6.COLOR_MAX; // auto-saved//#GEN#[-1]#PJ#
            width=_omp__parallelRegionVarHolderInstance_6.width; // auto-saved//#GEN#[-1]#PJ#
            random=_omp__parallelRegionVarHolderInstance_6.random; // auto-saved//#GEN#[-1]#PJ#
            pixels=_omp__parallelRegionVarHolderInstance_6.pixels; // auto-saved//#GEN#[-1]#PJ#
            PJPackageOnly.setThreadCountCurrentParallelRegion(1);
        }
        /*OpenMP Parallel region (#6) -- END */

        Bitmap bmOut = Bitmap.createBitmap(width, height, source.getConfig());
        bmOut.setPixels(pixels, 0, width, 0, 0, width, height);
        source.recycle();
        source = null;
        return bmOut;
    }
    }
    static private AtomicBoolean _imFirst_8 = new AtomicBoolean(true);
    static private AtomicInteger _imFinishedCounter_8 = new AtomicInteger(0);
    static private CountDownLatch _waitBarrier_8 = new CountDownLatch(1);
    static private CountDownLatch _waitBarrierAfter_8 = new CountDownLatch(1);
    static private ParIterator<Integer> _pi_8 = null;
    static private Integer _lastElement_8 = null;
    static private _ompWorkSharedUserCode_BitmapProcessing8_variables _ompWorkSharedUserCode_BitmapProcessing8_variables_instance = null;
        static private void _ompWorkSharedUserCode_BitmapProcessing8(_ompWorkSharedUserCode_BitmapProcessing8_variables __omp_vars) {
//#GEN#[-1]#PJ#
        int width = __omp_vars.width; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int height = __omp_vars.height; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int[] pixels = __omp_vars.pixels; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int COLOR_MAX = __omp_vars.COLOR_MAX; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int index = __omp_vars.index; // Auto-saved//#GEN#[-1]#PJ#
        Bitmap source = __omp_vars.source; // Auto-saved//#GEN#[-1]#PJ#
        Random random = __omp_vars.random; // Auto-saved//#GEN#[-1]#PJ#
        Integer y;
        while (_pi_8.hasNext()) {
            y = _pi_8.next();
            
            {
                for (int x = 0; x < width; ++x) {
                    index = y * width + x;
                    int randColor = Color.rgb(random.nextInt(COLOR_MAX), random.nextInt(COLOR_MAX), random.nextInt(COLOR_MAX));
                    pixels[index] |= randColor;
                }
            }
        }
//#GEN#[-1]#PJ#
    __omp_vars.index = index; // Re-collected//#GEN#[-1]#PJ#
    __omp_vars.source = source; // Re-collected//#GEN#[-1]#PJ#
    __omp_vars.random = random; // Re-collected//#GEN#[-1]#PJ#
    }
    
    
    /* Parallel region, placed in a multi-task */
    TASK(Pyjama.omp_get_num_threads()-1) private static void _ompParallelRegion_6(_omp__parallelRegionVarHolderClass_BitmapProcessing6 __omp_vars) {
//#GEN#[-1]#PJ#
        int index = __omp_vars.index; // Auto-saved//#GEN#[-1]#PJ#
        int height = __omp_vars.height; // Auto-saved//#GEN#[-1]#PJ#
        Bitmap source = __omp_vars.source; // Auto-saved//#GEN#[-1]#PJ#
        int COLOR_MAX = __omp_vars.COLOR_MAX; // Auto-saved//#GEN#[-1]#PJ#
        int width = __omp_vars.width; // Auto-saved//#GEN#[-1]#PJ#
        Random random = __omp_vars.random; // Auto-saved//#GEN#[-1]#PJ#
        int[] pixels = __omp_vars.pixels; // Auto-saved//#GEN#[-1]#PJ#
        {
            if ( Pyjama.insideParallelRegion() ) {
                /* Share the following work-sharing construct amongst multiple threads only if inside a parallel region (need this check for orphaned work-sharing constructs) */
                boolean _omp_imFirst = _imFirst_8.getAndSet(false);
                _holderForPIFirst = _imFirst_8;
                if (_omp_imFirst) {
                    _ompWorkSharedUserCode_BitmapProcessing8_variables_instance = new _ompWorkSharedUserCode_BitmapProcessing8_variables();
                    int __omp_size_ = 0;
                    // TODO -- improve performance by calculating N from the parameters (as an equation) rather than looping
                    for (int y = 0; y < height; y = y+1) {
                        _lastElement_8 = y;
                        __omp_size_++;
                        }
                    _pi_8 = ParIteratorFactory.createParIterator(0, __omp_size_, 1, Pyjama.omp_get_num_threads(), ParIterator.Schedule.DYNAMIC, 10, false);
                    _omp_piVarContainer.add(_pi_8); // for interrupt statement
                    _pi_8.setThreadIdGenerator(new UniqueThreadIdGeneratorForOpenMP());//#GEN#[-1]#PJ#
//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing8_variables_instance.width = width; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing8_variables_instance.height = height; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing8_variables_instance.pixels = pixels; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing8_variables_instance.COLOR_MAX = COLOR_MAX; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing8_variables_instance.index = index; // auto-saving
                    _ompWorkSharedUserCode_BitmapProcessing8_variables_instance.source = source; // auto-saving
                    _ompWorkSharedUserCode_BitmapProcessing8_variables_instance.random = random; // auto-saving
                    _waitBarrier_8.countDown();
                } else {
                    try { _waitBarrier_8.await(); } catch (InterruptedException __omp__ie) { __omp__ie.printStackTrace(); }
                }
                _ompWorkSharedUserCode_BitmapProcessing8(_ompWorkSharedUserCode_BitmapProcessing8_variables_instance);
                if (_imFinishedCounter_8.incrementAndGet() == PJPackageOnly.getThreadCountCurrentParallelRegion()) {
                    _waitBarrierAfter_8.countDown();
                } else {
                    try { 
                        _waitBarrierAfter_8.await();
                    } catch (InterruptedException __omp__ie) { 
                        __omp__ie.printStackTrace(); 
                    }
                }
                // TODO: recollect
//#GEN#[-1]#PJ#
            } else {
                /* Otherwise, this orphaned work-sharing is not within a parallel region.. so execute sequentially */
                for (int y = 0; y < height; y = y+1) {
                    for (int x = 0; x < __omp_vars.width; ++x) {
                        __omp_vars.index = y * __omp_vars.width + x;
                        int randColor = Color.rgb(__omp_vars.random.nextInt(__omp_vars.COLOR_MAX), __omp_vars.random.nextInt(__omp_vars.COLOR_MAX), __omp_vars.random.nextInt(__omp_vars.COLOR_MAX));
                        __omp_vars.pixels[__omp_vars.index] |= randColor;
                    }
                }
            }

        }
//#GEN#[-1]#PJ#
        __omp_vars.index = index; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.height = height; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.source = source; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.COLOR_MAX = COLOR_MAX; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.width = width; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.random = random; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.pixels = pixels; // restore auto-saved variable//#GEN#[-1]#PJ#
    }
    public static Bitmap brightness(Bitmap src, int value) {{
        int width = src.getWidth();
        int height = src.getHeight();
        Bitmap bmOut = Bitmap.createBitmap(width, height, src.getConfig());
        int A = 0, R = 0, G = 0, B = 0;
        int pixel = 0;
        /*OpenMP Parallel region (#9) -- START */
        if(Pyjama.insideParallelRegion() ) {
            /* If already inside a parallel region, execute sequentially (nested parallelism currently not supported) */
            {
                for (int x = 0; x < width; x = x+1) {
                    for (int y = 0; y < height; ++y) {
                        pixel = src.getPixel(x, y);
                        A = Color.alpha(pixel);
                        R = Color.red(pixel);
                        G = Color.green(pixel);
                        B = Color.blue(pixel);
                        R += value;
                        if (R > 255) {
                            R = 255;
                        } else if (R < 0) {
                            R = 0;
                        }
                        G += value;
                        if (G > 255) {
                            G = 255;
                        } else if (G < 0) {
                            G = 0;
                        }
                        B += value;
                        if (B > 255) {
                            B = 255;
                        } else if (B < 0) {
                            B = 0;
                        }
                        bmOut.setPixel(x, y, Color.argb(A, R, G, B));
                    }
                }
            }
        } else {
            /* Else, execute in parallel */
            PJPackageOnly.setThreadCountCurrentParallelRegion(Pyjama.omp_get_num_threads());

            /* Process data clauses */
            _omp__parallelRegionVarHolderClass_BitmapProcessing9 _omp__parallelRegionVarHolderInstance_9 = new _omp__parallelRegionVarHolderClass_BitmapProcessing9();
            _omp__parallelRegionVarHolderInstance_9.bmOut = bmOut; // auto-saving
            _omp__parallelRegionVarHolderInstance_9.G = G; // auto-saving
            _omp__parallelRegionVarHolderInstance_9.height = height; // auto-saving
            _omp__parallelRegionVarHolderInstance_9.pixel = pixel; // auto-saving
            _omp__parallelRegionVarHolderInstance_9.A = A; // auto-saving
            _omp__parallelRegionVarHolderInstance_9.B = B; // auto-saving
            _omp__parallelRegionVarHolderInstance_9.R = R; // auto-saving
            _omp__parallelRegionVarHolderInstance_9.width = width; // auto-saving
            _omp__parallelRegionVarHolderInstance_9.value = value; // auto-saving
            _omp__parallelRegionVarHolderInstance_9.src = src; // auto-saving

            /* Execute using traditional OpenMP (master thread part of the team) */
            PJPackageOnly.setMasterThread(Thread.currentThread());
            TaskID _omp__parallelRegionTaskID_9 = _ompParallelRegion_9(_omp__parallelRegionVarHolderInstance_9);
            __pt___ompParallelRegion_9(_omp__parallelRegionVarHolderInstance_9);
            try {_omp__parallelRegionTaskID_9.waitTillFinished();} catch(Exception __pt__ex) { __pt__ex.printStackTrace(); }
            
            PJPackageOnly.setMasterThread(null);
            _holderForPIFirst.set(true);
//#GEN#[-1]#PJ#
            bmOut=_omp__parallelRegionVarHolderInstance_9.bmOut; // auto-saved//#GEN#[-1]#PJ#
            G=_omp__parallelRegionVarHolderInstance_9.G; // auto-saved//#GEN#[-1]#PJ#
            height=_omp__parallelRegionVarHolderInstance_9.height; // auto-saved//#GEN#[-1]#PJ#
            pixel=_omp__parallelRegionVarHolderInstance_9.pixel; // auto-saved//#GEN#[-1]#PJ#
            A=_omp__parallelRegionVarHolderInstance_9.A; // auto-saved//#GEN#[-1]#PJ#
            B=_omp__parallelRegionVarHolderInstance_9.B; // auto-saved//#GEN#[-1]#PJ#
            R=_omp__parallelRegionVarHolderInstance_9.R; // auto-saved//#GEN#[-1]#PJ#
            width=_omp__parallelRegionVarHolderInstance_9.width; // auto-saved//#GEN#[-1]#PJ#
            value=_omp__parallelRegionVarHolderInstance_9.value; // auto-saved//#GEN#[-1]#PJ#
            src=_omp__parallelRegionVarHolderInstance_9.src; // auto-saved//#GEN#[-1]#PJ#
            PJPackageOnly.setThreadCountCurrentParallelRegion(1);
        }
        /*OpenMP Parallel region (#9) -- END */

        src.recycle();
        src = null;
        return bmOut;
    }
    }
    static private AtomicBoolean _imFirst_11 = new AtomicBoolean(true);
    static private AtomicInteger _imFinishedCounter_11 = new AtomicInteger(0);
    static private CountDownLatch _waitBarrier_11 = new CountDownLatch(1);
    static private CountDownLatch _waitBarrierAfter_11 = new CountDownLatch(1);
    static private ParIterator<Integer> _pi_11 = null;
    static private Integer _lastElement_11 = null;
    static private _ompWorkSharedUserCode_BitmapProcessing11_variables _ompWorkSharedUserCode_BitmapProcessing11_variables_instance = null;
        static private void _ompWorkSharedUserCode_BitmapProcessing11(_ompWorkSharedUserCode_BitmapProcessing11_variables __omp_vars) {
//#GEN#[-1]#PJ#
        int width = __omp_vars.width; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int height = __omp_vars.height; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int A = __omp_vars.A; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int R = __omp_vars.R; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int G = __omp_vars.G; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int B = __omp_vars.B; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int pixel = __omp_vars.pixel; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        Bitmap bmOut = __omp_vars.bmOut; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int value = __omp_vars.value; // Auto-saved//#GEN#[-1]#PJ#
        Bitmap src = __omp_vars.src; // Auto-saved//#GEN#[-1]#PJ#
        Integer x;
        while (_pi_11.hasNext()) {
            x = _pi_11.next();
            
            {
                for (int y = 0; y < height; ++y) {
                    pixel = src.getPixel(x, y);
                    A = Color.alpha(pixel);
                    R = Color.red(pixel);
                    G = Color.green(pixel);
                    B = Color.blue(pixel);
                    R += value;
                    if (R > 255) {
                        R = 255;
                    } else if (R < 0) {
                        R = 0;
                    }
                    G += value;
                    if (G > 255) {
                        G = 255;
                    } else if (G < 0) {
                        G = 0;
                    }
                    B += value;
                    if (B > 255) {
                        B = 255;
                    } else if (B < 0) {
                        B = 0;
                    }
                    bmOut.setPixel(x, y, Color.argb(A, R, G, B));
                }
            }
        }
//#GEN#[-1]#PJ#
    __omp_vars.value = value; // Re-collected//#GEN#[-1]#PJ#
    __omp_vars.src = src; // Re-collected//#GEN#[-1]#PJ#
    }
    
    
    /* Parallel region, placed in a multi-task */
    TASK(Pyjama.omp_get_num_threads()-1) private static void _ompParallelRegion_9(_omp__parallelRegionVarHolderClass_BitmapProcessing9 __omp_vars) {
//#GEN#[-1]#PJ#
        Bitmap bmOut = __omp_vars.bmOut; // Auto-saved//#GEN#[-1]#PJ#
        int G = __omp_vars.G; // Auto-saved//#GEN#[-1]#PJ#
        int height = __omp_vars.height; // Auto-saved//#GEN#[-1]#PJ#
        int pixel = __omp_vars.pixel; // Auto-saved//#GEN#[-1]#PJ#
        int A = __omp_vars.A; // Auto-saved//#GEN#[-1]#PJ#
        int B = __omp_vars.B; // Auto-saved//#GEN#[-1]#PJ#
        int R = __omp_vars.R; // Auto-saved//#GEN#[-1]#PJ#
        int width = __omp_vars.width; // Auto-saved//#GEN#[-1]#PJ#
        int value = __omp_vars.value; // Auto-saved//#GEN#[-1]#PJ#
        Bitmap src = __omp_vars.src; // Auto-saved//#GEN#[-1]#PJ#
        {
            if ( Pyjama.insideParallelRegion() ) {
                /* Share the following work-sharing construct amongst multiple threads only if inside a parallel region (need this check for orphaned work-sharing constructs) */
                boolean _omp_imFirst = _imFirst_11.getAndSet(false);
                _holderForPIFirst = _imFirst_11;
                if (_omp_imFirst) {
                    _ompWorkSharedUserCode_BitmapProcessing11_variables_instance = new _ompWorkSharedUserCode_BitmapProcessing11_variables();
                    int __omp_size_ = 0;
                    // TODO -- improve performance by calculating N from the parameters (as an equation) rather than looping
                    for (int x = 0; x < width; x = x+1) {
                        _lastElement_11 = x;
                        __omp_size_++;
                        }
                    _pi_11 = ParIteratorFactory.createParIterator(0, __omp_size_, 1, Pyjama.omp_get_num_threads(), ParIterator.Schedule.DYNAMIC, 10, false);
                    _omp_piVarContainer.add(_pi_11); // for interrupt statement
                    _pi_11.setThreadIdGenerator(new UniqueThreadIdGeneratorForOpenMP());//#GEN#[-1]#PJ#
//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing11_variables_instance.width = width; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing11_variables_instance.height = height; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing11_variables_instance.A = A; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing11_variables_instance.R = R; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing11_variables_instance.G = G; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing11_variables_instance.B = B; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing11_variables_instance.pixel = pixel; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing11_variables_instance.bmOut = bmOut; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing11_variables_instance.value = value; // auto-saving
                    _ompWorkSharedUserCode_BitmapProcessing11_variables_instance.src = src; // auto-saving
                    _waitBarrier_11.countDown();
                } else {
                    try { _waitBarrier_11.await(); } catch (InterruptedException __omp__ie) { __omp__ie.printStackTrace(); }
                }
                _ompWorkSharedUserCode_BitmapProcessing11(_ompWorkSharedUserCode_BitmapProcessing11_variables_instance);
                if (_imFinishedCounter_11.incrementAndGet() == PJPackageOnly.getThreadCountCurrentParallelRegion()) {
                    _waitBarrierAfter_11.countDown();
                } else {
                    try { 
                        _waitBarrierAfter_11.await();
                    } catch (InterruptedException __omp__ie) { 
                        __omp__ie.printStackTrace(); 
                    }
                }
                // TODO: recollect
//#GEN#[-1]#PJ#
            } else {
                /* Otherwise, this orphaned work-sharing is not within a parallel region.. so execute sequentially */
                for (int x = 0; x < width; x = x+1) {
                    for (int y = 0; y < __omp_vars.height; ++y) {
                        __omp_vars.pixel = __omp_vars.src.getPixel(x, y);
                        __omp_vars.A = Color.alpha(__omp_vars.pixel);
                        __omp_vars.R = Color.red(__omp_vars.pixel);
                        __omp_vars.G = Color.green(__omp_vars.pixel);
                        __omp_vars.B = Color.blue(__omp_vars.pixel);
                        __omp_vars.R += __omp_vars.value;
                        if (__omp_vars.R > 255) {
                            __omp_vars.R = 255;
                        } else if (__omp_vars.R < 0) {
                            __omp_vars.R = 0;
                        }
                        __omp_vars.G += __omp_vars.value;
                        if (__omp_vars.G > 255) {
                            __omp_vars.G = 255;
                        } else if (__omp_vars.G < 0) {
                            __omp_vars.G = 0;
                        }
                        __omp_vars.B += __omp_vars.value;
                        if (__omp_vars.B > 255) {
                            __omp_vars.B = 255;
                        } else if (__omp_vars.B < 0) {
                            __omp_vars.B = 0;
                        }
                        __omp_vars.bmOut.setPixel(x, y, Color.argb(__omp_vars.A, __omp_vars.R, __omp_vars.G, __omp_vars.B));
                    }
                }
            }

        }
//#GEN#[-1]#PJ#
        __omp_vars.bmOut = bmOut; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.G = G; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.height = height; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.pixel = pixel; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.A = A; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.B = B; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.R = R; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.width = width; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.value = value; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.src = src; // restore auto-saved variable//#GEN#[-1]#PJ#
    }
    public static Bitmap sepia(Bitmap src) {{
        int width = src.getWidth();
        int height = src.getHeight();
        Bitmap bmOut = Bitmap.createBitmap(width, height, src.getConfig());
        double GS_RED = 0.3;
        double GS_GREEN = 0.59;
        double GS_BLUE = 0.11;
        int A = 0, R = 0, G = 0, B = 0;
        int pixel = 0;
        /*OpenMP Parallel region (#12) -- START */
        if(Pyjama.insideParallelRegion() ) {
            /* If already inside a parallel region, execute sequentially (nested parallelism currently not supported) */
            {
                for (int x = 0; x < width; x = x+1) {
                    for (int y = 0; y < height; ++y) {
                        pixel = src.getPixel(x, y);
                        A = Color.alpha(pixel);
                        R = Color.red(pixel);
                        G = Color.green(pixel);
                        B = Color.blue(pixel);
                        B = G = R = (int) (GS_RED * R + GS_GREEN * G + GS_BLUE * B);
                        R += 110;
                        if (R > 255) {
                            R = 255;
                        }
                        G += 65;
                        if (G > 255) {
                            G = 255;
                        }
                        B += 20;
                        if (B > 255) {
                            B = 255;
                        }
                        bmOut.setPixel(x, y, Color.argb(A, R, G, B));
                    }
                }
            }
        } else {
            /* Else, execute in parallel */
            PJPackageOnly.setThreadCountCurrentParallelRegion(Pyjama.omp_get_num_threads());

            /* Process data clauses */
            _omp__parallelRegionVarHolderClass_BitmapProcessing12 _omp__parallelRegionVarHolderInstance_12 = new _omp__parallelRegionVarHolderClass_BitmapProcessing12();
            _omp__parallelRegionVarHolderInstance_12.GS_GREEN = GS_GREEN; // auto-saving
            _omp__parallelRegionVarHolderInstance_12.bmOut = bmOut; // auto-saving
            _omp__parallelRegionVarHolderInstance_12.G = G; // auto-saving
            _omp__parallelRegionVarHolderInstance_12.height = height; // auto-saving
            _omp__parallelRegionVarHolderInstance_12.pixel = pixel; // auto-saving
            _omp__parallelRegionVarHolderInstance_12.A = A; // auto-saving
            _omp__parallelRegionVarHolderInstance_12.B = B; // auto-saving
            _omp__parallelRegionVarHolderInstance_12.GS_BLUE = GS_BLUE; // auto-saving
            _omp__parallelRegionVarHolderInstance_12.R = R; // auto-saving
            _omp__parallelRegionVarHolderInstance_12.width = width; // auto-saving
            _omp__parallelRegionVarHolderInstance_12.src = src; // auto-saving
            _omp__parallelRegionVarHolderInstance_12.GS_RED = GS_RED; // auto-saving

            /* Execute using traditional OpenMP (master thread part of the team) */
            PJPackageOnly.setMasterThread(Thread.currentThread());
            TaskID _omp__parallelRegionTaskID_12 = _ompParallelRegion_12(_omp__parallelRegionVarHolderInstance_12);
            __pt___ompParallelRegion_12(_omp__parallelRegionVarHolderInstance_12);
            try {_omp__parallelRegionTaskID_12.waitTillFinished();} catch(Exception __pt__ex) { __pt__ex.printStackTrace(); }
            
            PJPackageOnly.setMasterThread(null);
            _holderForPIFirst.set(true);
//#GEN#[-1]#PJ#
            GS_GREEN=_omp__parallelRegionVarHolderInstance_12.GS_GREEN; // auto-saved//#GEN#[-1]#PJ#
            bmOut=_omp__parallelRegionVarHolderInstance_12.bmOut; // auto-saved//#GEN#[-1]#PJ#
            G=_omp__parallelRegionVarHolderInstance_12.G; // auto-saved//#GEN#[-1]#PJ#
            height=_omp__parallelRegionVarHolderInstance_12.height; // auto-saved//#GEN#[-1]#PJ#
            pixel=_omp__parallelRegionVarHolderInstance_12.pixel; // auto-saved//#GEN#[-1]#PJ#
            A=_omp__parallelRegionVarHolderInstance_12.A; // auto-saved//#GEN#[-1]#PJ#
            B=_omp__parallelRegionVarHolderInstance_12.B; // auto-saved//#GEN#[-1]#PJ#
            GS_BLUE=_omp__parallelRegionVarHolderInstance_12.GS_BLUE; // auto-saved//#GEN#[-1]#PJ#
            R=_omp__parallelRegionVarHolderInstance_12.R; // auto-saved//#GEN#[-1]#PJ#
            width=_omp__parallelRegionVarHolderInstance_12.width; // auto-saved//#GEN#[-1]#PJ#
            src=_omp__parallelRegionVarHolderInstance_12.src; // auto-saved//#GEN#[-1]#PJ#
            GS_RED=_omp__parallelRegionVarHolderInstance_12.GS_RED; // auto-saved//#GEN#[-1]#PJ#
            PJPackageOnly.setThreadCountCurrentParallelRegion(1);
        }
        /*OpenMP Parallel region (#12) -- END */

        src.recycle();
        src = null;
        return bmOut;
    }
    }
    static private AtomicBoolean _imFirst_14 = new AtomicBoolean(true);
    static private AtomicInteger _imFinishedCounter_14 = new AtomicInteger(0);
    static private CountDownLatch _waitBarrier_14 = new CountDownLatch(1);
    static private CountDownLatch _waitBarrierAfter_14 = new CountDownLatch(1);
    static private ParIterator<Integer> _pi_14 = null;
    static private Integer _lastElement_14 = null;
    static private _ompWorkSharedUserCode_BitmapProcessing14_variables _ompWorkSharedUserCode_BitmapProcessing14_variables_instance = null;
        static private void _ompWorkSharedUserCode_BitmapProcessing14(_ompWorkSharedUserCode_BitmapProcessing14_variables __omp_vars) {
//#GEN#[-1]#PJ#
        int width = __omp_vars.width; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int height = __omp_vars.height; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int A = __omp_vars.A; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int R = __omp_vars.R; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int G = __omp_vars.G; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int B = __omp_vars.B; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int pixel = __omp_vars.pixel; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        Bitmap bmOut = __omp_vars.bmOut; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        double GS_GREEN = __omp_vars.GS_GREEN; // Auto-saved//#GEN#[-1]#PJ#
        double GS_BLUE = __omp_vars.GS_BLUE; // Auto-saved//#GEN#[-1]#PJ#
        Bitmap src = __omp_vars.src; // Auto-saved//#GEN#[-1]#PJ#
        double GS_RED = __omp_vars.GS_RED; // Auto-saved//#GEN#[-1]#PJ#
        Integer x;
        while (_pi_14.hasNext()) {
            x = _pi_14.next();
            
            {
                for (int y = 0; y < height; ++y) {
                    pixel = src.getPixel(x, y);
                    A = Color.alpha(pixel);
                    R = Color.red(pixel);
                    G = Color.green(pixel);
                    B = Color.blue(pixel);
                    B = G = R = (int) (GS_RED * R + GS_GREEN * G + GS_BLUE * B);
                    R += 110;
                    if (R > 255) {
                        R = 255;
                    }
                    G += 65;
                    if (G > 255) {
                        G = 255;
                    }
                    B += 20;
                    if (B > 255) {
                        B = 255;
                    }
                    bmOut.setPixel(x, y, Color.argb(A, R, G, B));
                }
            }
        }
//#GEN#[-1]#PJ#
    __omp_vars.GS_GREEN = GS_GREEN; // Re-collected//#GEN#[-1]#PJ#
    __omp_vars.GS_BLUE = GS_BLUE; // Re-collected//#GEN#[-1]#PJ#
    __omp_vars.src = src; // Re-collected//#GEN#[-1]#PJ#
    __omp_vars.GS_RED = GS_RED; // Re-collected//#GEN#[-1]#PJ#
    }
    
    
    /* Parallel region, placed in a multi-task */
    TASK(Pyjama.omp_get_num_threads()-1) private static void _ompParallelRegion_12(_omp__parallelRegionVarHolderClass_BitmapProcessing12 __omp_vars) {
//#GEN#[-1]#PJ#
        double GS_GREEN = __omp_vars.GS_GREEN; // Auto-saved//#GEN#[-1]#PJ#
        Bitmap bmOut = __omp_vars.bmOut; // Auto-saved//#GEN#[-1]#PJ#
        int G = __omp_vars.G; // Auto-saved//#GEN#[-1]#PJ#
        int height = __omp_vars.height; // Auto-saved//#GEN#[-1]#PJ#
        int pixel = __omp_vars.pixel; // Auto-saved//#GEN#[-1]#PJ#
        int A = __omp_vars.A; // Auto-saved//#GEN#[-1]#PJ#
        int B = __omp_vars.B; // Auto-saved//#GEN#[-1]#PJ#
        double GS_BLUE = __omp_vars.GS_BLUE; // Auto-saved//#GEN#[-1]#PJ#
        int R = __omp_vars.R; // Auto-saved//#GEN#[-1]#PJ#
        int width = __omp_vars.width; // Auto-saved//#GEN#[-1]#PJ#
        Bitmap src = __omp_vars.src; // Auto-saved//#GEN#[-1]#PJ#
        double GS_RED = __omp_vars.GS_RED; // Auto-saved//#GEN#[-1]#PJ#
        {
            if ( Pyjama.insideParallelRegion() ) {
                /* Share the following work-sharing construct amongst multiple threads only if inside a parallel region (need this check for orphaned work-sharing constructs) */
                boolean _omp_imFirst = _imFirst_14.getAndSet(false);
                _holderForPIFirst = _imFirst_14;
                if (_omp_imFirst) {
                    _ompWorkSharedUserCode_BitmapProcessing14_variables_instance = new _ompWorkSharedUserCode_BitmapProcessing14_variables();
                    int __omp_size_ = 0;
                    // TODO -- improve performance by calculating N from the parameters (as an equation) rather than looping
                    for (int x = 0; x < width; x = x+1) {
                        _lastElement_14 = x;
                        __omp_size_++;
                        }
                    _pi_14 = ParIteratorFactory.createParIterator(0, __omp_size_, 1, Pyjama.omp_get_num_threads(), ParIterator.Schedule.DYNAMIC, 10, false);
                    _omp_piVarContainer.add(_pi_14); // for interrupt statement
                    _pi_14.setThreadIdGenerator(new UniqueThreadIdGeneratorForOpenMP());//#GEN#[-1]#PJ#
//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing14_variables_instance.width = width; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing14_variables_instance.height = height; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing14_variables_instance.A = A; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing14_variables_instance.R = R; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing14_variables_instance.G = G; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing14_variables_instance.B = B; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing14_variables_instance.pixel = pixel; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing14_variables_instance.bmOut = bmOut; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing14_variables_instance.GS_GREEN = GS_GREEN; // auto-saving
                    _ompWorkSharedUserCode_BitmapProcessing14_variables_instance.GS_BLUE = GS_BLUE; // auto-saving
                    _ompWorkSharedUserCode_BitmapProcessing14_variables_instance.src = src; // auto-saving
                    _ompWorkSharedUserCode_BitmapProcessing14_variables_instance.GS_RED = GS_RED; // auto-saving
                    _waitBarrier_14.countDown();
                } else {
                    try { _waitBarrier_14.await(); } catch (InterruptedException __omp__ie) { __omp__ie.printStackTrace(); }
                }
                _ompWorkSharedUserCode_BitmapProcessing14(_ompWorkSharedUserCode_BitmapProcessing14_variables_instance);
                if (_imFinishedCounter_14.incrementAndGet() == PJPackageOnly.getThreadCountCurrentParallelRegion()) {
                    _waitBarrierAfter_14.countDown();
                } else {
                    try { 
                        _waitBarrierAfter_14.await();
                    } catch (InterruptedException __omp__ie) { 
                        __omp__ie.printStackTrace(); 
                    }
                }
                // TODO: recollect
//#GEN#[-1]#PJ#
            } else {
                /* Otherwise, this orphaned work-sharing is not within a parallel region.. so execute sequentially */
                for (int x = 0; x < width; x = x+1) {
                    for (int y = 0; y < __omp_vars.height; ++y) {
                        __omp_vars.pixel = __omp_vars.src.getPixel(x, y);
                        __omp_vars.A = Color.alpha(__omp_vars.pixel);
                        __omp_vars.R = Color.red(__omp_vars.pixel);
                        __omp_vars.G = Color.green(__omp_vars.pixel);
                        __omp_vars.B = Color.blue(__omp_vars.pixel);
                        __omp_vars.B = __omp_vars.G = __omp_vars.R = (int) (__omp_vars.GS_RED * __omp_vars.R + __omp_vars.GS_GREEN * __omp_vars.G + __omp_vars.GS_BLUE * __omp_vars.B);
                        __omp_vars.R += 110;
                        if (__omp_vars.R > 255) {
                            __omp_vars.R = 255;
                        }
                        __omp_vars.G += 65;
                        if (__omp_vars.G > 255) {
                            __omp_vars.G = 255;
                        }
                        __omp_vars.B += 20;
                        if (__omp_vars.B > 255) {
                            __omp_vars.B = 255;
                        }
                        __omp_vars.bmOut.setPixel(x, y, Color.argb(__omp_vars.A, __omp_vars.R, __omp_vars.G, __omp_vars.B));
                    }
                }
            }

        }
//#GEN#[-1]#PJ#
        __omp_vars.GS_GREEN = GS_GREEN; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.bmOut = bmOut; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.G = G; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.height = height; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.pixel = pixel; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.A = A; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.B = B; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.GS_BLUE = GS_BLUE; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.R = R; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.width = width; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.src = src; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.GS_RED = GS_RED; // restore auto-saved variable//#GEN#[-1]#PJ#
    }
    public static Bitmap gamma(Bitmap src, double red, double green, double blue) {{
        red = (double) (red + 2) / 10.0;
        green = (double) (green + 2) / 10.0;
        blue = (double) (blue + 2) / 10.0;
        Bitmap bmOut = Bitmap.createBitmap(src.getWidth(), src.getHeight(), src.getConfig());
        int width = src.getWidth();
        int height = src.getHeight();
        int A = 0, R = 0, G = 0, B = 0;
        int pixel = 0;
        int MAX_SIZE = 256;
        double MAX_VALUE_DBL = 255.0;
        int MAX_VALUE_INT = 255;
        double REVERSE = 1.0;
        int[] gammaR = new int[MAX_SIZE];
        int[] gammaG = new int[MAX_SIZE];
        int[] gammaB = new int[MAX_SIZE];
        /*OpenMP Parallel region (#15) -- START */
        if(Pyjama.insideParallelRegion() ) {
            /* If already inside a parallel region, execute sequentially (nested parallelism currently not supported) */
            {
                for (int i = 0; i < MAX_SIZE; i = i+1) {
                    gammaR[i] = (int) Math.min(MAX_VALUE_INT, (int) ((MAX_VALUE_DBL * Math.pow(i / MAX_VALUE_DBL, REVERSE / red)) + 0.5));
                    gammaG[i] = (int) Math.min(MAX_VALUE_INT, (int) ((MAX_VALUE_DBL * Math.pow(i / MAX_VALUE_DBL, REVERSE / green)) + 0.5));
                    gammaB[i] = (int) Math.min(MAX_VALUE_INT, (int) ((MAX_VALUE_DBL * Math.pow(i / MAX_VALUE_DBL, REVERSE / blue)) + 0.5));
                }
            }
        } else {
            /* Else, execute in parallel */
            PJPackageOnly.setThreadCountCurrentParallelRegion(Pyjama.omp_get_num_threads());

            /* Process data clauses */
            _omp__parallelRegionVarHolderClass_BitmapProcessing15 _omp__parallelRegionVarHolderInstance_15 = new _omp__parallelRegionVarHolderClass_BitmapProcessing15();
            _omp__parallelRegionVarHolderInstance_15.MAX_VALUE_INT = MAX_VALUE_INT; // auto-saving
            _omp__parallelRegionVarHolderInstance_15.G = G; // auto-saving
            _omp__parallelRegionVarHolderInstance_15.pixel = pixel; // auto-saving
            _omp__parallelRegionVarHolderInstance_15.A = A; // auto-saving
            _omp__parallelRegionVarHolderInstance_15.green = green; // auto-saving
            _omp__parallelRegionVarHolderInstance_15.MAX_SIZE = MAX_SIZE; // auto-saving
            _omp__parallelRegionVarHolderInstance_15.B = B; // auto-saving
            _omp__parallelRegionVarHolderInstance_15.width = width; // auto-saving
            _omp__parallelRegionVarHolderInstance_15.gammaB = gammaB; // auto-saving
            _omp__parallelRegionVarHolderInstance_15.bmOut = bmOut; // auto-saving
            _omp__parallelRegionVarHolderInstance_15.red = red; // auto-saving
            _omp__parallelRegionVarHolderInstance_15.height = height; // auto-saving
            _omp__parallelRegionVarHolderInstance_15.blue = blue; // auto-saving
            _omp__parallelRegionVarHolderInstance_15.gammaR = gammaR; // auto-saving
            _omp__parallelRegionVarHolderInstance_15.R = R; // auto-saving
            _omp__parallelRegionVarHolderInstance_15.MAX_VALUE_DBL = MAX_VALUE_DBL; // auto-saving
            _omp__parallelRegionVarHolderInstance_15.REVERSE = REVERSE; // auto-saving
            _omp__parallelRegionVarHolderInstance_15.src = src; // auto-saving
            _omp__parallelRegionVarHolderInstance_15.gammaG = gammaG; // auto-saving

            /* Execute using traditional OpenMP (master thread part of the team) */
            PJPackageOnly.setMasterThread(Thread.currentThread());
            TaskID _omp__parallelRegionTaskID_15 = _ompParallelRegion_15(_omp__parallelRegionVarHolderInstance_15);
            __pt___ompParallelRegion_15(_omp__parallelRegionVarHolderInstance_15);
            try {_omp__parallelRegionTaskID_15.waitTillFinished();} catch(Exception __pt__ex) { __pt__ex.printStackTrace(); }
            
            PJPackageOnly.setMasterThread(null);
            _holderForPIFirst.set(true);
//#GEN#[-1]#PJ#
            MAX_VALUE_INT=_omp__parallelRegionVarHolderInstance_15.MAX_VALUE_INT; // auto-saved//#GEN#[-1]#PJ#
            G=_omp__parallelRegionVarHolderInstance_15.G; // auto-saved//#GEN#[-1]#PJ#
            pixel=_omp__parallelRegionVarHolderInstance_15.pixel; // auto-saved//#GEN#[-1]#PJ#
            A=_omp__parallelRegionVarHolderInstance_15.A; // auto-saved//#GEN#[-1]#PJ#
            green=_omp__parallelRegionVarHolderInstance_15.green; // auto-saved//#GEN#[-1]#PJ#
            MAX_SIZE=_omp__parallelRegionVarHolderInstance_15.MAX_SIZE; // auto-saved//#GEN#[-1]#PJ#
            B=_omp__parallelRegionVarHolderInstance_15.B; // auto-saved//#GEN#[-1]#PJ#
            width=_omp__parallelRegionVarHolderInstance_15.width; // auto-saved//#GEN#[-1]#PJ#
            gammaB=_omp__parallelRegionVarHolderInstance_15.gammaB; // auto-saved//#GEN#[-1]#PJ#
            bmOut=_omp__parallelRegionVarHolderInstance_15.bmOut; // auto-saved//#GEN#[-1]#PJ#
            red=_omp__parallelRegionVarHolderInstance_15.red; // auto-saved//#GEN#[-1]#PJ#
            height=_omp__parallelRegionVarHolderInstance_15.height; // auto-saved//#GEN#[-1]#PJ#
            blue=_omp__parallelRegionVarHolderInstance_15.blue; // auto-saved//#GEN#[-1]#PJ#
            gammaR=_omp__parallelRegionVarHolderInstance_15.gammaR; // auto-saved//#GEN#[-1]#PJ#
            R=_omp__parallelRegionVarHolderInstance_15.R; // auto-saved//#GEN#[-1]#PJ#
            MAX_VALUE_DBL=_omp__parallelRegionVarHolderInstance_15.MAX_VALUE_DBL; // auto-saved//#GEN#[-1]#PJ#
            REVERSE=_omp__parallelRegionVarHolderInstance_15.REVERSE; // auto-saved//#GEN#[-1]#PJ#
            src=_omp__parallelRegionVarHolderInstance_15.src; // auto-saved//#GEN#[-1]#PJ#
            gammaG=_omp__parallelRegionVarHolderInstance_15.gammaG; // auto-saved//#GEN#[-1]#PJ#
            PJPackageOnly.setThreadCountCurrentParallelRegion(1);
        }
        /*OpenMP Parallel region (#15) -- END */

        /*OpenMP Parallel region (#18) -- START */
        if(Pyjama.insideParallelRegion() ) {
            /* If already inside a parallel region, execute sequentially (nested parallelism currently not supported) */
            {
                for (int x = 0; x < width; x = x+1) {
                    for (int y = 0; y < height; y++) {
                        pixel = src.getPixel(x, y);
                        A = Color.alpha(pixel);
                        R = gammaR[Color.red(pixel)];
                        G = gammaG[Color.green(pixel)];
                        B = gammaB[Color.blue(pixel)];
                        bmOut.setPixel(x, y, Color.argb(A, R, G, B));
                    }
                }
            }
        } else {
            /* Else, execute in parallel */
            PJPackageOnly.setThreadCountCurrentParallelRegion(Pyjama.omp_get_num_threads());

            /* Process data clauses */
            _omp__parallelRegionVarHolderClass_BitmapProcessing18 _omp__parallelRegionVarHolderInstance_18 = new _omp__parallelRegionVarHolderClass_BitmapProcessing18();
            _omp__parallelRegionVarHolderInstance_18.G = G; // auto-saving
            _omp__parallelRegionVarHolderInstance_18.MAX_VALUE_INT = MAX_VALUE_INT; // auto-saving
            _omp__parallelRegionVarHolderInstance_18.A = A; // auto-saving
            _omp__parallelRegionVarHolderInstance_18.pixel = pixel; // auto-saving
            _omp__parallelRegionVarHolderInstance_18.B = B; // auto-saving
            _omp__parallelRegionVarHolderInstance_18.MAX_SIZE = MAX_SIZE; // auto-saving
            _omp__parallelRegionVarHolderInstance_18.green = green; // auto-saving
            _omp__parallelRegionVarHolderInstance_18.width = width; // auto-saving
            _omp__parallelRegionVarHolderInstance_18.gammaB = gammaB; // auto-saving
            _omp__parallelRegionVarHolderInstance_18.bmOut = bmOut; // auto-saving
            _omp__parallelRegionVarHolderInstance_18.height = height; // auto-saving
            _omp__parallelRegionVarHolderInstance_18.red = red; // auto-saving
            _omp__parallelRegionVarHolderInstance_18.blue = blue; // auto-saving
            _omp__parallelRegionVarHolderInstance_18.gammaR = gammaR; // auto-saving
            _omp__parallelRegionVarHolderInstance_18.R = R; // auto-saving
            _omp__parallelRegionVarHolderInstance_18.MAX_VALUE_DBL = MAX_VALUE_DBL; // auto-saving
            _omp__parallelRegionVarHolderInstance_18.REVERSE = REVERSE; // auto-saving
            _omp__parallelRegionVarHolderInstance_18.src = src; // auto-saving
            _omp__parallelRegionVarHolderInstance_18.gammaG = gammaG; // auto-saving

            /* Execute using traditional OpenMP (master thread part of the team) */
            PJPackageOnly.setMasterThread(Thread.currentThread());
            TaskID _omp__parallelRegionTaskID_18 = _ompParallelRegion_18(_omp__parallelRegionVarHolderInstance_18);
            __pt___ompParallelRegion_18(_omp__parallelRegionVarHolderInstance_18);
            try {_omp__parallelRegionTaskID_18.waitTillFinished();} catch(Exception __pt__ex) { __pt__ex.printStackTrace(); }
            
            PJPackageOnly.setMasterThread(null);
            _holderForPIFirst.set(true);
//#GEN#[-1]#PJ#
            G=_omp__parallelRegionVarHolderInstance_18.G; // auto-saved//#GEN#[-1]#PJ#
            MAX_VALUE_INT=_omp__parallelRegionVarHolderInstance_18.MAX_VALUE_INT; // auto-saved//#GEN#[-1]#PJ#
            A=_omp__parallelRegionVarHolderInstance_18.A; // auto-saved//#GEN#[-1]#PJ#
            pixel=_omp__parallelRegionVarHolderInstance_18.pixel; // auto-saved//#GEN#[-1]#PJ#
            B=_omp__parallelRegionVarHolderInstance_18.B; // auto-saved//#GEN#[-1]#PJ#
            MAX_SIZE=_omp__parallelRegionVarHolderInstance_18.MAX_SIZE; // auto-saved//#GEN#[-1]#PJ#
            green=_omp__parallelRegionVarHolderInstance_18.green; // auto-saved//#GEN#[-1]#PJ#
            width=_omp__parallelRegionVarHolderInstance_18.width; // auto-saved//#GEN#[-1]#PJ#
            gammaB=_omp__parallelRegionVarHolderInstance_18.gammaB; // auto-saved//#GEN#[-1]#PJ#
            bmOut=_omp__parallelRegionVarHolderInstance_18.bmOut; // auto-saved//#GEN#[-1]#PJ#
            height=_omp__parallelRegionVarHolderInstance_18.height; // auto-saved//#GEN#[-1]#PJ#
            red=_omp__parallelRegionVarHolderInstance_18.red; // auto-saved//#GEN#[-1]#PJ#
            blue=_omp__parallelRegionVarHolderInstance_18.blue; // auto-saved//#GEN#[-1]#PJ#
            gammaR=_omp__parallelRegionVarHolderInstance_18.gammaR; // auto-saved//#GEN#[-1]#PJ#
            R=_omp__parallelRegionVarHolderInstance_18.R; // auto-saved//#GEN#[-1]#PJ#
            MAX_VALUE_DBL=_omp__parallelRegionVarHolderInstance_18.MAX_VALUE_DBL; // auto-saved//#GEN#[-1]#PJ#
            REVERSE=_omp__parallelRegionVarHolderInstance_18.REVERSE; // auto-saved//#GEN#[-1]#PJ#
            src=_omp__parallelRegionVarHolderInstance_18.src; // auto-saved//#GEN#[-1]#PJ#
            gammaG=_omp__parallelRegionVarHolderInstance_18.gammaG; // auto-saved//#GEN#[-1]#PJ#
            PJPackageOnly.setThreadCountCurrentParallelRegion(1);
        }
        /*OpenMP Parallel region (#18) -- END */

        src.recycle();
        src = null;
        return bmOut;
    }
    }
    static private AtomicBoolean _imFirst_17 = new AtomicBoolean(true);
    static private AtomicInteger _imFinishedCounter_17 = new AtomicInteger(0);
    static private CountDownLatch _waitBarrier_17 = new CountDownLatch(1);
    static private CountDownLatch _waitBarrierAfter_17 = new CountDownLatch(1);
    static private ParIterator<Integer> _pi_17 = null;
    static private Integer _lastElement_17 = null;
    static private _ompWorkSharedUserCode_BitmapProcessing17_variables _ompWorkSharedUserCode_BitmapProcessing17_variables_instance = null;
        static private void _ompWorkSharedUserCode_BitmapProcessing17(_ompWorkSharedUserCode_BitmapProcessing17_variables __omp_vars) {
//#GEN#[-1]#PJ#
        int MAX_SIZE = __omp_vars.MAX_SIZE; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int[] gammaR = __omp_vars.gammaR; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int[] gammaG = __omp_vars.gammaG; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int[] gammaB = __omp_vars.gammaB; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int MAX_VALUE_INT = __omp_vars.MAX_VALUE_INT; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        double MAX_VALUE_DBL = __omp_vars.MAX_VALUE_DBL; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        double REVERSE = __omp_vars.REVERSE; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        double red = __omp_vars.red; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        double green = __omp_vars.green; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        double blue = __omp_vars.blue; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int G = __omp_vars.G; // Auto-saved//#GEN#[-1]#PJ#
        int A = __omp_vars.A; // Auto-saved//#GEN#[-1]#PJ#
        int pixel = __omp_vars.pixel; // Auto-saved//#GEN#[-1]#PJ#
        int B = __omp_vars.B; // Auto-saved//#GEN#[-1]#PJ#
        int width = __omp_vars.width; // Auto-saved//#GEN#[-1]#PJ#
        Bitmap bmOut = __omp_vars.bmOut; // Auto-saved//#GEN#[-1]#PJ#
        int height = __omp_vars.height; // Auto-saved//#GEN#[-1]#PJ#
        int R = __omp_vars.R; // Auto-saved//#GEN#[-1]#PJ#
        Bitmap src = __omp_vars.src; // Auto-saved//#GEN#[-1]#PJ#
        Integer i;
        while (_pi_17.hasNext()) {
            i = _pi_17.next();
            
            {
                gammaR[i] = (int) Math.min(MAX_VALUE_INT, (int) ((MAX_VALUE_DBL * Math.pow(i / MAX_VALUE_DBL, REVERSE / red)) + 0.5));
                gammaG[i] = (int) Math.min(MAX_VALUE_INT, (int) ((MAX_VALUE_DBL * Math.pow(i / MAX_VALUE_DBL, REVERSE / green)) + 0.5));
                gammaB[i] = (int) Math.min(MAX_VALUE_INT, (int) ((MAX_VALUE_DBL * Math.pow(i / MAX_VALUE_DBL, REVERSE / blue)) + 0.5));
            }
        }
//#GEN#[-1]#PJ#
    __omp_vars.G = G; // Re-collected//#GEN#[-1]#PJ#
    __omp_vars.A = A; // Re-collected//#GEN#[-1]#PJ#
    __omp_vars.pixel = pixel; // Re-collected//#GEN#[-1]#PJ#
    __omp_vars.B = B; // Re-collected//#GEN#[-1]#PJ#
    __omp_vars.width = width; // Re-collected//#GEN#[-1]#PJ#
    __omp_vars.bmOut = bmOut; // Re-collected//#GEN#[-1]#PJ#
    __omp_vars.height = height; // Re-collected//#GEN#[-1]#PJ#
    __omp_vars.R = R; // Re-collected//#GEN#[-1]#PJ#
    __omp_vars.src = src; // Re-collected//#GEN#[-1]#PJ#
    }
    
    
    /* Parallel region, placed in a multi-task */
    TASK(Pyjama.omp_get_num_threads()-1) private static void _ompParallelRegion_15(_omp__parallelRegionVarHolderClass_BitmapProcessing15 __omp_vars) {
//#GEN#[-1]#PJ#
        int MAX_VALUE_INT = __omp_vars.MAX_VALUE_INT; // Auto-saved//#GEN#[-1]#PJ#
        int G = __omp_vars.G; // Auto-saved//#GEN#[-1]#PJ#
        int pixel = __omp_vars.pixel; // Auto-saved//#GEN#[-1]#PJ#
        int A = __omp_vars.A; // Auto-saved//#GEN#[-1]#PJ#
        double green = __omp_vars.green; // Auto-saved//#GEN#[-1]#PJ#
        int MAX_SIZE = __omp_vars.MAX_SIZE; // Auto-saved//#GEN#[-1]#PJ#
        int B = __omp_vars.B; // Auto-saved//#GEN#[-1]#PJ#
        int width = __omp_vars.width; // Auto-saved//#GEN#[-1]#PJ#
        int[] gammaB = __omp_vars.gammaB; // Auto-saved//#GEN#[-1]#PJ#
        Bitmap bmOut = __omp_vars.bmOut; // Auto-saved//#GEN#[-1]#PJ#
        double red = __omp_vars.red; // Auto-saved//#GEN#[-1]#PJ#
        int height = __omp_vars.height; // Auto-saved//#GEN#[-1]#PJ#
        double blue = __omp_vars.blue; // Auto-saved//#GEN#[-1]#PJ#
        int[] gammaR = __omp_vars.gammaR; // Auto-saved//#GEN#[-1]#PJ#
        int R = __omp_vars.R; // Auto-saved//#GEN#[-1]#PJ#
        double MAX_VALUE_DBL = __omp_vars.MAX_VALUE_DBL; // Auto-saved//#GEN#[-1]#PJ#
        double REVERSE = __omp_vars.REVERSE; // Auto-saved//#GEN#[-1]#PJ#
        Bitmap src = __omp_vars.src; // Auto-saved//#GEN#[-1]#PJ#
        int[] gammaG = __omp_vars.gammaG; // Auto-saved//#GEN#[-1]#PJ#
        {
            if ( Pyjama.insideParallelRegion() ) {
                /* Share the following work-sharing construct amongst multiple threads only if inside a parallel region (need this check for orphaned work-sharing constructs) */
                boolean _omp_imFirst = _imFirst_17.getAndSet(false);
                _holderForPIFirst = _imFirst_17;
                if (_omp_imFirst) {
                    _ompWorkSharedUserCode_BitmapProcessing17_variables_instance = new _ompWorkSharedUserCode_BitmapProcessing17_variables();
                    int __omp_size_ = 0;
                    // TODO -- improve performance by calculating N from the parameters (as an equation) rather than looping
                    for (int i = 0; i < MAX_SIZE; i = i+1) {
                        _lastElement_17 = i;
                        __omp_size_++;
                        }
                    _pi_17 = ParIteratorFactory.createParIterator(0, __omp_size_, 1, Pyjama.omp_get_num_threads(), ParIterator.Schedule.DYNAMIC, 10, false);
                    _omp_piVarContainer.add(_pi_17); // for interrupt statement
                    _pi_17.setThreadIdGenerator(new UniqueThreadIdGeneratorForOpenMP());//#GEN#[-1]#PJ#
//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing17_variables_instance.MAX_SIZE = MAX_SIZE; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing17_variables_instance.gammaR = gammaR; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing17_variables_instance.gammaG = gammaG; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing17_variables_instance.gammaB = gammaB; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing17_variables_instance.MAX_VALUE_INT = MAX_VALUE_INT; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing17_variables_instance.MAX_VALUE_DBL = MAX_VALUE_DBL; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing17_variables_instance.REVERSE = REVERSE; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing17_variables_instance.red = red; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing17_variables_instance.green = green; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing17_variables_instance.blue = blue; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing17_variables_instance.G = G; // auto-saving
                    _ompWorkSharedUserCode_BitmapProcessing17_variables_instance.A = A; // auto-saving
                    _ompWorkSharedUserCode_BitmapProcessing17_variables_instance.pixel = pixel; // auto-saving
                    _ompWorkSharedUserCode_BitmapProcessing17_variables_instance.B = B; // auto-saving
                    _ompWorkSharedUserCode_BitmapProcessing17_variables_instance.width = width; // auto-saving
                    _ompWorkSharedUserCode_BitmapProcessing17_variables_instance.bmOut = bmOut; // auto-saving
                    _ompWorkSharedUserCode_BitmapProcessing17_variables_instance.height = height; // auto-saving
                    _ompWorkSharedUserCode_BitmapProcessing17_variables_instance.R = R; // auto-saving
                    _ompWorkSharedUserCode_BitmapProcessing17_variables_instance.src = src; // auto-saving
                    _waitBarrier_17.countDown();
                } else {
                    try { _waitBarrier_17.await(); } catch (InterruptedException __omp__ie) { __omp__ie.printStackTrace(); }
                }
                _ompWorkSharedUserCode_BitmapProcessing17(_ompWorkSharedUserCode_BitmapProcessing17_variables_instance);
                if (_imFinishedCounter_17.incrementAndGet() == PJPackageOnly.getThreadCountCurrentParallelRegion()) {
                    _waitBarrierAfter_17.countDown();
                } else {
                    try { 
                        _waitBarrierAfter_17.await();
                    } catch (InterruptedException __omp__ie) { 
                        __omp__ie.printStackTrace(); 
                    }
                }
                // TODO: recollect
//#GEN#[-1]#PJ#
            } else {
                /* Otherwise, this orphaned work-sharing is not within a parallel region.. so execute sequentially */
                for (int i = 0; i < MAX_SIZE; i = i+1) {
                    __omp_vars.gammaR[i] = (int) Math.min(__omp_vars.MAX_VALUE_INT, (int) ((__omp_vars.MAX_VALUE_DBL * Math.pow(i / __omp_vars.MAX_VALUE_DBL, __omp_vars.REVERSE / __omp_vars.red)) + 0.5));
                    __omp_vars.gammaG[i] = (int) Math.min(__omp_vars.MAX_VALUE_INT, (int) ((__omp_vars.MAX_VALUE_DBL * Math.pow(i / __omp_vars.MAX_VALUE_DBL, __omp_vars.REVERSE / __omp_vars.green)) + 0.5));
                    __omp_vars.gammaB[i] = (int) Math.min(__omp_vars.MAX_VALUE_INT, (int) ((__omp_vars.MAX_VALUE_DBL * Math.pow(i / __omp_vars.MAX_VALUE_DBL, __omp_vars.REVERSE / __omp_vars.blue)) + 0.5));
                }
            }

        }
//#GEN#[-1]#PJ#
        __omp_vars.MAX_VALUE_INT = MAX_VALUE_INT; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.G = G; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.pixel = pixel; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.A = A; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.green = green; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.MAX_SIZE = MAX_SIZE; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.B = B; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.width = width; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.gammaB = gammaB; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.bmOut = bmOut; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.red = red; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.height = height; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.blue = blue; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.gammaR = gammaR; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.R = R; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.MAX_VALUE_DBL = MAX_VALUE_DBL; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.REVERSE = REVERSE; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.src = src; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.gammaG = gammaG; // restore auto-saved variable//#GEN#[-1]#PJ#
    }static private AtomicBoolean _imFirst_20 = new AtomicBoolean(true);
    static private AtomicInteger _imFinishedCounter_20 = new AtomicInteger(0);
    static private CountDownLatch _waitBarrier_20 = new CountDownLatch(1);
    static private CountDownLatch _waitBarrierAfter_20 = new CountDownLatch(1);
    static private ParIterator<Integer> _pi_20 = null;
    static private Integer _lastElement_20 = null;
    static private _ompWorkSharedUserCode_BitmapProcessing20_variables _ompWorkSharedUserCode_BitmapProcessing20_variables_instance = null;
        static private void _ompWorkSharedUserCode_BitmapProcessing20(_ompWorkSharedUserCode_BitmapProcessing20_variables __omp_vars) {
//#GEN#[-1]#PJ#
        int width = __omp_vars.width; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int height = __omp_vars.height; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int A = __omp_vars.A; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int R = __omp_vars.R; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int G = __omp_vars.G; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int B = __omp_vars.B; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int pixel = __omp_vars.pixel; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int[] gammaR = __omp_vars.gammaR; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int[] gammaG = __omp_vars.gammaG; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int[] gammaB = __omp_vars.gammaB; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        Bitmap bmOut = __omp_vars.bmOut; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int MAX_VALUE_INT = __omp_vars.MAX_VALUE_INT; // Auto-saved//#GEN#[-1]#PJ#
        int MAX_SIZE = __omp_vars.MAX_SIZE; // Auto-saved//#GEN#[-1]#PJ#
        double green = __omp_vars.green; // Auto-saved//#GEN#[-1]#PJ#
        double red = __omp_vars.red; // Auto-saved//#GEN#[-1]#PJ#
        double blue = __omp_vars.blue; // Auto-saved//#GEN#[-1]#PJ#
        double MAX_VALUE_DBL = __omp_vars.MAX_VALUE_DBL; // Auto-saved//#GEN#[-1]#PJ#
        double REVERSE = __omp_vars.REVERSE; // Auto-saved//#GEN#[-1]#PJ#
        Bitmap src = __omp_vars.src; // Auto-saved//#GEN#[-1]#PJ#
        Integer x;
        while (_pi_20.hasNext()) {
            x = _pi_20.next();
            
            {
                for (int y = 0; y < height; y++) {
                    pixel = src.getPixel(x, y);
                    A = Color.alpha(pixel);
                    R = gammaR[Color.red(pixel)];
                    G = gammaG[Color.green(pixel)];
                    B = gammaB[Color.blue(pixel)];
                    bmOut.setPixel(x, y, Color.argb(A, R, G, B));
                }
            }
        }
//#GEN#[-1]#PJ#
    __omp_vars.MAX_VALUE_INT = MAX_VALUE_INT; // Re-collected//#GEN#[-1]#PJ#
    __omp_vars.MAX_SIZE = MAX_SIZE; // Re-collected//#GEN#[-1]#PJ#
    __omp_vars.green = green; // Re-collected//#GEN#[-1]#PJ#
    __omp_vars.red = red; // Re-collected//#GEN#[-1]#PJ#
    __omp_vars.blue = blue; // Re-collected//#GEN#[-1]#PJ#
    __omp_vars.MAX_VALUE_DBL = MAX_VALUE_DBL; // Re-collected//#GEN#[-1]#PJ#
    __omp_vars.REVERSE = REVERSE; // Re-collected//#GEN#[-1]#PJ#
    __omp_vars.src = src; // Re-collected//#GEN#[-1]#PJ#
    }
    
    
    /* Parallel region, placed in a multi-task */
    TASK(Pyjama.omp_get_num_threads()-1) private static void _ompParallelRegion_18(_omp__parallelRegionVarHolderClass_BitmapProcessing18 __omp_vars) {
//#GEN#[-1]#PJ#
        int G = __omp_vars.G; // Auto-saved//#GEN#[-1]#PJ#
        int MAX_VALUE_INT = __omp_vars.MAX_VALUE_INT; // Auto-saved//#GEN#[-1]#PJ#
        int A = __omp_vars.A; // Auto-saved//#GEN#[-1]#PJ#
        int pixel = __omp_vars.pixel; // Auto-saved//#GEN#[-1]#PJ#
        int B = __omp_vars.B; // Auto-saved//#GEN#[-1]#PJ#
        int MAX_SIZE = __omp_vars.MAX_SIZE; // Auto-saved//#GEN#[-1]#PJ#
        double green = __omp_vars.green; // Auto-saved//#GEN#[-1]#PJ#
        int width = __omp_vars.width; // Auto-saved//#GEN#[-1]#PJ#
        int[] gammaB = __omp_vars.gammaB; // Auto-saved//#GEN#[-1]#PJ#
        Bitmap bmOut = __omp_vars.bmOut; // Auto-saved//#GEN#[-1]#PJ#
        int height = __omp_vars.height; // Auto-saved//#GEN#[-1]#PJ#
        double red = __omp_vars.red; // Auto-saved//#GEN#[-1]#PJ#
        double blue = __omp_vars.blue; // Auto-saved//#GEN#[-1]#PJ#
        int[] gammaR = __omp_vars.gammaR; // Auto-saved//#GEN#[-1]#PJ#
        int R = __omp_vars.R; // Auto-saved//#GEN#[-1]#PJ#
        double MAX_VALUE_DBL = __omp_vars.MAX_VALUE_DBL; // Auto-saved//#GEN#[-1]#PJ#
        double REVERSE = __omp_vars.REVERSE; // Auto-saved//#GEN#[-1]#PJ#
        Bitmap src = __omp_vars.src; // Auto-saved//#GEN#[-1]#PJ#
        int[] gammaG = __omp_vars.gammaG; // Auto-saved//#GEN#[-1]#PJ#
        {
            if ( Pyjama.insideParallelRegion() ) {
                /* Share the following work-sharing construct amongst multiple threads only if inside a parallel region (need this check for orphaned work-sharing constructs) */
                boolean _omp_imFirst = _imFirst_20.getAndSet(false);
                _holderForPIFirst = _imFirst_20;
                if (_omp_imFirst) {
                    _ompWorkSharedUserCode_BitmapProcessing20_variables_instance = new _ompWorkSharedUserCode_BitmapProcessing20_variables();
                    int __omp_size_ = 0;
                    // TODO -- improve performance by calculating N from the parameters (as an equation) rather than looping
                    for (int x = 0; x < width; x = x+1) {
                        _lastElement_20 = x;
                        __omp_size_++;
                        }
                    _pi_20 = ParIteratorFactory.createParIterator(0, __omp_size_, 1, Pyjama.omp_get_num_threads(), ParIterator.Schedule.DYNAMIC, 10, false);
                    _omp_piVarContainer.add(_pi_20); // for interrupt statement
                    _pi_20.setThreadIdGenerator(new UniqueThreadIdGeneratorForOpenMP());//#GEN#[-1]#PJ#
//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing20_variables_instance.width = width; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing20_variables_instance.height = height; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing20_variables_instance.A = A; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing20_variables_instance.R = R; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing20_variables_instance.G = G; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing20_variables_instance.B = B; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing20_variables_instance.pixel = pixel; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing20_variables_instance.gammaR = gammaR; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing20_variables_instance.gammaG = gammaG; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing20_variables_instance.gammaB = gammaB; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing20_variables_instance.bmOut = bmOut; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing20_variables_instance.MAX_VALUE_INT = MAX_VALUE_INT; // auto-saving
                    _ompWorkSharedUserCode_BitmapProcessing20_variables_instance.MAX_SIZE = MAX_SIZE; // auto-saving
                    _ompWorkSharedUserCode_BitmapProcessing20_variables_instance.green = green; // auto-saving
                    _ompWorkSharedUserCode_BitmapProcessing20_variables_instance.red = red; // auto-saving
                    _ompWorkSharedUserCode_BitmapProcessing20_variables_instance.blue = blue; // auto-saving
                    _ompWorkSharedUserCode_BitmapProcessing20_variables_instance.MAX_VALUE_DBL = MAX_VALUE_DBL; // auto-saving
                    _ompWorkSharedUserCode_BitmapProcessing20_variables_instance.REVERSE = REVERSE; // auto-saving
                    _ompWorkSharedUserCode_BitmapProcessing20_variables_instance.src = src; // auto-saving
                    _waitBarrier_20.countDown();
                } else {
                    try { _waitBarrier_20.await(); } catch (InterruptedException __omp__ie) { __omp__ie.printStackTrace(); }
                }
                _ompWorkSharedUserCode_BitmapProcessing20(_ompWorkSharedUserCode_BitmapProcessing20_variables_instance);
                if (_imFinishedCounter_20.incrementAndGet() == PJPackageOnly.getThreadCountCurrentParallelRegion()) {
                    _waitBarrierAfter_20.countDown();
                } else {
                    try { 
                        _waitBarrierAfter_20.await();
                    } catch (InterruptedException __omp__ie) { 
                        __omp__ie.printStackTrace(); 
                    }
                }
                // TODO: recollect
//#GEN#[-1]#PJ#
            } else {
                /* Otherwise, this orphaned work-sharing is not within a parallel region.. so execute sequentially */
                for (int x = 0; x < width; x = x+1) {
                    for (int y = 0; y < __omp_vars.height; y++) {
                        __omp_vars.pixel = __omp_vars.src.getPixel(x, y);
                        __omp_vars.A = Color.alpha(__omp_vars.pixel);
                        __omp_vars.R = __omp_vars.gammaR[Color.red(__omp_vars.pixel)];
                        __omp_vars.G = __omp_vars.gammaG[Color.green(__omp_vars.pixel)];
                        __omp_vars.B = __omp_vars.gammaB[Color.blue(__omp_vars.pixel)];
                        __omp_vars.bmOut.setPixel(x, y, Color.argb(__omp_vars.A, __omp_vars.R, __omp_vars.G, __omp_vars.B));
                    }
                }
            }

        }
//#GEN#[-1]#PJ#
        __omp_vars.G = G; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.MAX_VALUE_INT = MAX_VALUE_INT; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.A = A; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.pixel = pixel; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.B = B; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.MAX_SIZE = MAX_SIZE; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.green = green; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.width = width; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.gammaB = gammaB; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.bmOut = bmOut; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.height = height; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.red = red; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.blue = blue; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.gammaR = gammaR; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.R = R; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.MAX_VALUE_DBL = MAX_VALUE_DBL; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.REVERSE = REVERSE; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.src = src; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.gammaG = gammaG; // restore auto-saved variable//#GEN#[-1]#PJ#
    }
    public static Bitmap contrast(Bitmap src, double value) {{
        int width = src.getWidth();
        int height = src.getHeight();
        Bitmap bmOut = Bitmap.createBitmap(width, height, src.getConfig());
        Canvas c = new Canvas();
        c.setBitmap(bmOut);
        c.drawBitmap(src, 0, 0, new Paint(Color.BLACK));
        int A = 0, R = 0, G = 0, B = 0;
        int pixel = 0;
        double contrast = Math.pow((100 + value) / 100, 2);
        /*OpenMP Parallel region (#21) -- START */
        if(Pyjama.insideParallelRegion() ) {
            /* If already inside a parallel region, execute sequentially (nested parallelism currently not supported) */
            {
                for (int x = 0; x < width; x = x+1) {
                    for (int y = 0; y < height; ++y) {
                        pixel = src.getPixel(x, y);
                        A = Color.alpha(pixel);
                        R = Color.red(pixel);
                        R = (int) (((((R / 255.0) - 0.5) * contrast) + 0.5) * 255.0);
                        if (R < 0) {
                            R = 0;
                        } else if (R > 255) {
                            R = 255;
                        }
                        G = Color.green(pixel);
                        G = (int) (((((G / 255.0) - 0.5) * contrast) + 0.5) * 255.0);
                        if (G < 0) {
                            G = 0;
                        } else if (G > 255) {
                            G = 255;
                        }
                        B = Color.blue(pixel);
                        B = (int) (((((B / 255.0) - 0.5) * contrast) + 0.5) * 255.0);
                        if (B < 0) {
                            B = 0;
                        } else if (B > 255) {
                            B = 255;
                        }
                        bmOut.setPixel(x, y, Color.argb(A, R, G, B));
                    }
                }
            }
        } else {
            /* Else, execute in parallel */
            PJPackageOnly.setThreadCountCurrentParallelRegion(Pyjama.omp_get_num_threads());

            /* Process data clauses */
            _omp__parallelRegionVarHolderClass_BitmapProcessing21 _omp__parallelRegionVarHolderInstance_21 = new _omp__parallelRegionVarHolderClass_BitmapProcessing21();
            _omp__parallelRegionVarHolderInstance_21.G = G; // auto-saving
            _omp__parallelRegionVarHolderInstance_21.pixel = pixel; // auto-saving
            _omp__parallelRegionVarHolderInstance_21.A = A; // auto-saving
            _omp__parallelRegionVarHolderInstance_21.c = c; // auto-saving
            _omp__parallelRegionVarHolderInstance_21.B = B; // auto-saving
            _omp__parallelRegionVarHolderInstance_21.width = width; // auto-saving
            _omp__parallelRegionVarHolderInstance_21.contrast = contrast; // auto-saving
            _omp__parallelRegionVarHolderInstance_21.bmOut = bmOut; // auto-saving
            _omp__parallelRegionVarHolderInstance_21.height = height; // auto-saving
            _omp__parallelRegionVarHolderInstance_21.R = R; // auto-saving
            _omp__parallelRegionVarHolderInstance_21.value = value; // auto-saving
            _omp__parallelRegionVarHolderInstance_21.src = src; // auto-saving

            /* Execute using traditional OpenMP (master thread part of the team) */
            PJPackageOnly.setMasterThread(Thread.currentThread());
            TaskID _omp__parallelRegionTaskID_21 = _ompParallelRegion_21(_omp__parallelRegionVarHolderInstance_21);
            __pt___ompParallelRegion_21(_omp__parallelRegionVarHolderInstance_21);
            try {_omp__parallelRegionTaskID_21.waitTillFinished();} catch(Exception __pt__ex) { __pt__ex.printStackTrace(); }
            
            PJPackageOnly.setMasterThread(null);
            _holderForPIFirst.set(true);
//#GEN#[-1]#PJ#
            G=_omp__parallelRegionVarHolderInstance_21.G; // auto-saved//#GEN#[-1]#PJ#
            pixel=_omp__parallelRegionVarHolderInstance_21.pixel; // auto-saved//#GEN#[-1]#PJ#
            A=_omp__parallelRegionVarHolderInstance_21.A; // auto-saved//#GEN#[-1]#PJ#
            c=_omp__parallelRegionVarHolderInstance_21.c; // auto-saved//#GEN#[-1]#PJ#
            B=_omp__parallelRegionVarHolderInstance_21.B; // auto-saved//#GEN#[-1]#PJ#
            width=_omp__parallelRegionVarHolderInstance_21.width; // auto-saved//#GEN#[-1]#PJ#
            contrast=_omp__parallelRegionVarHolderInstance_21.contrast; // auto-saved//#GEN#[-1]#PJ#
            bmOut=_omp__parallelRegionVarHolderInstance_21.bmOut; // auto-saved//#GEN#[-1]#PJ#
            height=_omp__parallelRegionVarHolderInstance_21.height; // auto-saved//#GEN#[-1]#PJ#
            R=_omp__parallelRegionVarHolderInstance_21.R; // auto-saved//#GEN#[-1]#PJ#
            value=_omp__parallelRegionVarHolderInstance_21.value; // auto-saved//#GEN#[-1]#PJ#
            src=_omp__parallelRegionVarHolderInstance_21.src; // auto-saved//#GEN#[-1]#PJ#
            PJPackageOnly.setThreadCountCurrentParallelRegion(1);
        }
        /*OpenMP Parallel region (#21) -- END */

        src.recycle();
        src = null;
        return bmOut;
    }
    }
    static private AtomicBoolean _imFirst_23 = new AtomicBoolean(true);
    static private AtomicInteger _imFinishedCounter_23 = new AtomicInteger(0);
    static private CountDownLatch _waitBarrier_23 = new CountDownLatch(1);
    static private CountDownLatch _waitBarrierAfter_23 = new CountDownLatch(1);
    static private ParIterator<Integer> _pi_23 = null;
    static private Integer _lastElement_23 = null;
    static private _ompWorkSharedUserCode_BitmapProcessing23_variables _ompWorkSharedUserCode_BitmapProcessing23_variables_instance = null;
        static private void _ompWorkSharedUserCode_BitmapProcessing23(_ompWorkSharedUserCode_BitmapProcessing23_variables __omp_vars) {
//#GEN#[-1]#PJ#
        int width = __omp_vars.width; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int height = __omp_vars.height; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int A = __omp_vars.A; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int R = __omp_vars.R; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int G = __omp_vars.G; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int B = __omp_vars.B; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int pixel = __omp_vars.pixel; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        Bitmap bmOut = __omp_vars.bmOut; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        Canvas c = __omp_vars.c; // Auto-saved//#GEN#[-1]#PJ#
        double contrast = __omp_vars.contrast; // Auto-saved//#GEN#[-1]#PJ#
        double value = __omp_vars.value; // Auto-saved//#GEN#[-1]#PJ#
        Bitmap src = __omp_vars.src; // Auto-saved//#GEN#[-1]#PJ#
        Integer x;
        while (_pi_23.hasNext()) {
            x = _pi_23.next();
            
            {
                for (int y = 0; y < height; ++y) {
                    pixel = src.getPixel(x, y);
                    A = Color.alpha(pixel);
                    R = Color.red(pixel);
                    R = (int) (((((R / 255.0) - 0.5) * contrast) + 0.5) * 255.0);
                    if (R < 0) {
                        R = 0;
                    } else if (R > 255) {
                        R = 255;
                    }
                    G = Color.green(pixel);
                    G = (int) (((((G / 255.0) - 0.5) * contrast) + 0.5) * 255.0);
                    if (G < 0) {
                        G = 0;
                    } else if (G > 255) {
                        G = 255;
                    }
                    B = Color.blue(pixel);
                    B = (int) (((((B / 255.0) - 0.5) * contrast) + 0.5) * 255.0);
                    if (B < 0) {
                        B = 0;
                    } else if (B > 255) {
                        B = 255;
                    }
                    bmOut.setPixel(x, y, Color.argb(A, R, G, B));
                }
            }
        }
//#GEN#[-1]#PJ#
    __omp_vars.c = c; // Re-collected//#GEN#[-1]#PJ#
    __omp_vars.contrast = contrast; // Re-collected//#GEN#[-1]#PJ#
    __omp_vars.value = value; // Re-collected//#GEN#[-1]#PJ#
    __omp_vars.src = src; // Re-collected//#GEN#[-1]#PJ#
    }
    
    
    /* Parallel region, placed in a multi-task */
    TASK(Pyjama.omp_get_num_threads()-1) private static void _ompParallelRegion_21(_omp__parallelRegionVarHolderClass_BitmapProcessing21 __omp_vars) {
//#GEN#[-1]#PJ#
        int G = __omp_vars.G; // Auto-saved//#GEN#[-1]#PJ#
        int pixel = __omp_vars.pixel; // Auto-saved//#GEN#[-1]#PJ#
        int A = __omp_vars.A; // Auto-saved//#GEN#[-1]#PJ#
        Canvas c = __omp_vars.c; // Auto-saved//#GEN#[-1]#PJ#
        int B = __omp_vars.B; // Auto-saved//#GEN#[-1]#PJ#
        int width = __omp_vars.width; // Auto-saved//#GEN#[-1]#PJ#
        double contrast = __omp_vars.contrast; // Auto-saved//#GEN#[-1]#PJ#
        Bitmap bmOut = __omp_vars.bmOut; // Auto-saved//#GEN#[-1]#PJ#
        int height = __omp_vars.height; // Auto-saved//#GEN#[-1]#PJ#
        int R = __omp_vars.R; // Auto-saved//#GEN#[-1]#PJ#
        double value = __omp_vars.value; // Auto-saved//#GEN#[-1]#PJ#
        Bitmap src = __omp_vars.src; // Auto-saved//#GEN#[-1]#PJ#
        {
            if ( Pyjama.insideParallelRegion() ) {
                /* Share the following work-sharing construct amongst multiple threads only if inside a parallel region (need this check for orphaned work-sharing constructs) */
                boolean _omp_imFirst = _imFirst_23.getAndSet(false);
                _holderForPIFirst = _imFirst_23;
                if (_omp_imFirst) {
                    _ompWorkSharedUserCode_BitmapProcessing23_variables_instance = new _ompWorkSharedUserCode_BitmapProcessing23_variables();
                    int __omp_size_ = 0;
                    // TODO -- improve performance by calculating N from the parameters (as an equation) rather than looping
                    for (int x = 0; x < width; x = x+1) {
                        _lastElement_23 = x;
                        __omp_size_++;
                        }
                    _pi_23 = ParIteratorFactory.createParIterator(0, __omp_size_, 1, Pyjama.omp_get_num_threads(), ParIterator.Schedule.DYNAMIC, 10, false);
                    _omp_piVarContainer.add(_pi_23); // for interrupt statement
                    _pi_23.setThreadIdGenerator(new UniqueThreadIdGeneratorForOpenMP());//#GEN#[-1]#PJ#
//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing23_variables_instance.width = width; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing23_variables_instance.height = height; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing23_variables_instance.A = A; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing23_variables_instance.R = R; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing23_variables_instance.G = G; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing23_variables_instance.B = B; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing23_variables_instance.pixel = pixel; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing23_variables_instance.bmOut = bmOut; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing23_variables_instance.c = c; // auto-saving
                    _ompWorkSharedUserCode_BitmapProcessing23_variables_instance.contrast = contrast; // auto-saving
                    _ompWorkSharedUserCode_BitmapProcessing23_variables_instance.value = value; // auto-saving
                    _ompWorkSharedUserCode_BitmapProcessing23_variables_instance.src = src; // auto-saving
                    _waitBarrier_23.countDown();
                } else {
                    try { _waitBarrier_23.await(); } catch (InterruptedException __omp__ie) { __omp__ie.printStackTrace(); }
                }
                _ompWorkSharedUserCode_BitmapProcessing23(_ompWorkSharedUserCode_BitmapProcessing23_variables_instance);
                if (_imFinishedCounter_23.incrementAndGet() == PJPackageOnly.getThreadCountCurrentParallelRegion()) {
                    _waitBarrierAfter_23.countDown();
                } else {
                    try { 
                        _waitBarrierAfter_23.await();
                    } catch (InterruptedException __omp__ie) { 
                        __omp__ie.printStackTrace(); 
                    }
                }
                // TODO: recollect
//#GEN#[-1]#PJ#
            } else {
                /* Otherwise, this orphaned work-sharing is not within a parallel region.. so execute sequentially */
                for (int x = 0; x < width; x = x+1) {
                    for (int y = 0; y < __omp_vars.height; ++y) {
                        __omp_vars.pixel = __omp_vars.src.getPixel(x, y);
                        __omp_vars.A = Color.alpha(__omp_vars.pixel);
                        __omp_vars.R = Color.red(__omp_vars.pixel);
                        __omp_vars.R = (int) (((((__omp_vars.R / 255.0) - 0.5) * __omp_vars.contrast) + 0.5) * 255.0);
                        if (__omp_vars.R < 0) {
                            __omp_vars.R = 0;
                        } else if (__omp_vars.R > 255) {
                            __omp_vars.R = 255;
                        }
                        __omp_vars.G = Color.green(__omp_vars.pixel);
                        __omp_vars.G = (int) (((((__omp_vars.G / 255.0) - 0.5) * __omp_vars.contrast) + 0.5) * 255.0);
                        if (__omp_vars.G < 0) {
                            __omp_vars.G = 0;
                        } else if (__omp_vars.G > 255) {
                            __omp_vars.G = 255;
                        }
                        __omp_vars.B = Color.blue(__omp_vars.pixel);
                        __omp_vars.B = (int) (((((__omp_vars.B / 255.0) - 0.5) * __omp_vars.contrast) + 0.5) * 255.0);
                        if (__omp_vars.B < 0) {
                            __omp_vars.B = 0;
                        } else if (__omp_vars.B > 255) {
                            __omp_vars.B = 255;
                        }
                        __omp_vars.bmOut.setPixel(x, y, Color.argb(__omp_vars.A, __omp_vars.R, __omp_vars.G, __omp_vars.B));
                    }
                }
            }

        }
//#GEN#[-1]#PJ#
        __omp_vars.G = G; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.pixel = pixel; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.A = A; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.c = c; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.B = B; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.width = width; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.contrast = contrast; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.bmOut = bmOut; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.height = height; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.R = R; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.value = value; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.src = src; // restore auto-saved variable//#GEN#[-1]#PJ#
    }
    public static Bitmap saturation(Bitmap src, int value) {{
        float f_value = (float) (value / 100.0);
        int w = src.getWidth();
        int h = src.getHeight();
        Bitmap bitmapResult = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);
        Canvas canvasResult = new Canvas(bitmapResult);
        Paint paint = new Paint();
        ColorMatrix colorMatrix = new ColorMatrix();
        colorMatrix.setSaturation(f_value);
        ColorMatrixColorFilter filter = new ColorMatrixColorFilter(colorMatrix);
        paint.setColorFilter(filter);
        canvasResult.drawBitmap(src, 0, 0, paint);
        src.recycle();
        src = null;
        return bitmapResult;
    }
    }
    
    public static Bitmap grayscale(Bitmap src) {{
        float[] GrayArray = { 0.213f, 0.715f, 0.072f, 0.0f, 0.0f, 0.213f, 0.715f, 0.072f, 0.0f, 0.0f, 0.213f, 0.715f, 0.072f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f };
        ColorMatrix colorMatrixGray = new ColorMatrix(GrayArray);
        int w = src.getWidth();
        int h = src.getHeight();
        Bitmap bitmapResult = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);
        Canvas canvasResult = new Canvas(bitmapResult);
        Paint paint = new Paint();
        ColorMatrixColorFilter filter = new ColorMatrixColorFilter(colorMatrixGray);
        paint.setColorFilter(filter);
        canvasResult.drawBitmap(src, 0, 0, paint);
        src.recycle();
        src = null;
        return bitmapResult;
    }
    }
    
    public static Bitmap vignette(Bitmap image) {{
        final int width = image.getWidth();
        final int height = image.getHeight();
        float radius = (float) (width / 1.2);
        int[] colors = new int[] { 0, 0x55000000, 0xff000000 };
        float[] positions = new float[] { 0.0f, 0.5f, 1.0f };
        RadialGradient gradient = new RadialGradient(width / 2, height / 2, radius, colors, positions, Shader.TileMode.CLAMP);
        Canvas canvas = new Canvas(image);
        canvas.drawARGB(1, 0, 0, 0);
        final Paint paint = new Paint();
        paint.setAntiAlias(true);
        paint.setColor(Color.BLACK);
        paint.setShader(gradient);
        final Rect rect = new Rect(0, 0, image.getWidth(), image.getHeight());
        final RectF rectf = new RectF(rect);
        canvas.drawRect(rectf, paint);
        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));
        canvas.drawBitmap(image, rect, rect, paint);
        return image;
    }
    }
    
    public static Bitmap hue(Bitmap bitmap, float hue) {{
        Bitmap newBitmap = bitmap.copy(bitmap.getConfig(), true);
        int width = newBitmap.getWidth();
        int height = newBitmap.getHeight();
        float[] hsv = new float[3];
        float _hue = hue;
        /*OpenMP Parallel region (#24) -- START */
        if(Pyjama.insideParallelRegion() ) {
            /* If already inside a parallel region, execute sequentially (nested parallelism currently not supported) */
            {
                for (int y = 0; y < height; y = y+1) {
                    for (int x = 0; x < width; x++) {
                        int pixel = newBitmap.getPixel(x, y);
                        Color.colorToHSV(pixel, hsv);
                        hsv[0] = _hue;
                        newBitmap.setPixel(x, y, Color.HSVToColor(Color.alpha(pixel), hsv));
                    }
                }
            }
        } else {
            /* Else, execute in parallel */
            PJPackageOnly.setThreadCountCurrentParallelRegion(Pyjama.omp_get_num_threads());

            /* Process data clauses */
            _omp__parallelRegionVarHolderClass_BitmapProcessing24 _omp__parallelRegionVarHolderInstance_24 = new _omp__parallelRegionVarHolderClass_BitmapProcessing24();
            _omp__parallelRegionVarHolderInstance_24.bitmap = bitmap; // auto-saving
            _omp__parallelRegionVarHolderInstance_24.hue = hue; // auto-saving
            _omp__parallelRegionVarHolderInstance_24.width = width; // auto-saving
            _omp__parallelRegionVarHolderInstance_24.height = height; // auto-saving
            _omp__parallelRegionVarHolderInstance_24._hue = _hue; // auto-saving
            _omp__parallelRegionVarHolderInstance_24.hsv = hsv; // auto-saving
            _omp__parallelRegionVarHolderInstance_24.newBitmap = newBitmap; // auto-saving

            /* Execute using traditional OpenMP (master thread part of the team) */
            PJPackageOnly.setMasterThread(Thread.currentThread());
            TaskID _omp__parallelRegionTaskID_24 = _ompParallelRegion_24(_omp__parallelRegionVarHolderInstance_24);
            __pt___ompParallelRegion_24(_omp__parallelRegionVarHolderInstance_24);
            try {_omp__parallelRegionTaskID_24.waitTillFinished();} catch(Exception __pt__ex) { __pt__ex.printStackTrace(); }
            
            PJPackageOnly.setMasterThread(null);
            _holderForPIFirst.set(true);
//#GEN#[-1]#PJ#
            bitmap=_omp__parallelRegionVarHolderInstance_24.bitmap; // auto-saved//#GEN#[-1]#PJ#
            hue=_omp__parallelRegionVarHolderInstance_24.hue; // auto-saved//#GEN#[-1]#PJ#
            width=_omp__parallelRegionVarHolderInstance_24.width; // auto-saved//#GEN#[-1]#PJ#
            height=_omp__parallelRegionVarHolderInstance_24.height; // auto-saved//#GEN#[-1]#PJ#
            _hue=_omp__parallelRegionVarHolderInstance_24._hue; // auto-saved//#GEN#[-1]#PJ#
            hsv=_omp__parallelRegionVarHolderInstance_24.hsv; // auto-saved//#GEN#[-1]#PJ#
            newBitmap=_omp__parallelRegionVarHolderInstance_24.newBitmap; // auto-saved//#GEN#[-1]#PJ#
            PJPackageOnly.setThreadCountCurrentParallelRegion(1);
        }
        /*OpenMP Parallel region (#24) -- END */

        bitmap.recycle();
        bitmap = null;
        return newBitmap;
    }
    }
    static private AtomicBoolean _imFirst_26 = new AtomicBoolean(true);
    static private AtomicInteger _imFinishedCounter_26 = new AtomicInteger(0);
    static private CountDownLatch _waitBarrier_26 = new CountDownLatch(1);
    static private CountDownLatch _waitBarrierAfter_26 = new CountDownLatch(1);
    static private ParIterator<Integer> _pi_26 = null;
    static private Integer _lastElement_26 = null;
    static private _ompWorkSharedUserCode_BitmapProcessing26_variables _ompWorkSharedUserCode_BitmapProcessing26_variables_instance = null;
        static private void _ompWorkSharedUserCode_BitmapProcessing26(_ompWorkSharedUserCode_BitmapProcessing26_variables __omp_vars) {
//#GEN#[-1]#PJ#
        int width = __omp_vars.width; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int height = __omp_vars.height; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        float[] hsv = __omp_vars.hsv; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        float _hue = __omp_vars._hue; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        Bitmap newBitmap = __omp_vars.newBitmap; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        Bitmap bitmap = __omp_vars.bitmap; // Auto-saved//#GEN#[-1]#PJ#
        float hue = __omp_vars.hue; // Auto-saved//#GEN#[-1]#PJ#
        Integer y;
        while (_pi_26.hasNext()) {
            y = _pi_26.next();
            
            {
                for (int x = 0; x < width; x++) {
                    int pixel = newBitmap.getPixel(x, y);
                    Color.colorToHSV(pixel, hsv);
                    hsv[0] = _hue;
                    newBitmap.setPixel(x, y, Color.HSVToColor(Color.alpha(pixel), hsv));
                }
            }
        }
//#GEN#[-1]#PJ#
    __omp_vars.bitmap = bitmap; // Re-collected//#GEN#[-1]#PJ#
    __omp_vars.hue = hue; // Re-collected//#GEN#[-1]#PJ#
    }
    
    
    /* Parallel region, placed in a multi-task */
    TASK(Pyjama.omp_get_num_threads()-1) private static void _ompParallelRegion_24(_omp__parallelRegionVarHolderClass_BitmapProcessing24 __omp_vars) {
//#GEN#[-1]#PJ#
        Bitmap bitmap = __omp_vars.bitmap; // Auto-saved//#GEN#[-1]#PJ#
        float hue = __omp_vars.hue; // Auto-saved//#GEN#[-1]#PJ#
        int width = __omp_vars.width; // Auto-saved//#GEN#[-1]#PJ#
        int height = __omp_vars.height; // Auto-saved//#GEN#[-1]#PJ#
        float _hue = __omp_vars._hue; // Auto-saved//#GEN#[-1]#PJ#
        float[] hsv = __omp_vars.hsv; // Auto-saved//#GEN#[-1]#PJ#
        Bitmap newBitmap = __omp_vars.newBitmap; // Auto-saved//#GEN#[-1]#PJ#
        {
            if ( Pyjama.insideParallelRegion() ) {
                /* Share the following work-sharing construct amongst multiple threads only if inside a parallel region (need this check for orphaned work-sharing constructs) */
                boolean _omp_imFirst = _imFirst_26.getAndSet(false);
                _holderForPIFirst = _imFirst_26;
                if (_omp_imFirst) {
                    _ompWorkSharedUserCode_BitmapProcessing26_variables_instance = new _ompWorkSharedUserCode_BitmapProcessing26_variables();
                    int __omp_size_ = 0;
                    // TODO -- improve performance by calculating N from the parameters (as an equation) rather than looping
                    for (int y = 0; y < height; y = y+1) {
                        _lastElement_26 = y;
                        __omp_size_++;
                        }
                    _pi_26 = ParIteratorFactory.createParIterator(0, __omp_size_, 1, Pyjama.omp_get_num_threads(), ParIterator.Schedule.DYNAMIC, 10, false);
                    _omp_piVarContainer.add(_pi_26); // for interrupt statement
                    _pi_26.setThreadIdGenerator(new UniqueThreadIdGeneratorForOpenMP());//#GEN#[-1]#PJ#
//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing26_variables_instance.width = width; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing26_variables_instance.height = height; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing26_variables_instance.hsv = hsv; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing26_variables_instance._hue = _hue; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing26_variables_instance.newBitmap = newBitmap; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing26_variables_instance.bitmap = bitmap; // auto-saving
                    _ompWorkSharedUserCode_BitmapProcessing26_variables_instance.hue = hue; // auto-saving
                    _waitBarrier_26.countDown();
                } else {
                    try { _waitBarrier_26.await(); } catch (InterruptedException __omp__ie) { __omp__ie.printStackTrace(); }
                }
                _ompWorkSharedUserCode_BitmapProcessing26(_ompWorkSharedUserCode_BitmapProcessing26_variables_instance);
                if (_imFinishedCounter_26.incrementAndGet() == PJPackageOnly.getThreadCountCurrentParallelRegion()) {
                    _waitBarrierAfter_26.countDown();
                } else {
                    try { 
                        _waitBarrierAfter_26.await();
                    } catch (InterruptedException __omp__ie) { 
                        __omp__ie.printStackTrace(); 
                    }
                }
                // TODO: recollect
//#GEN#[-1]#PJ#
            } else {
                /* Otherwise, this orphaned work-sharing is not within a parallel region.. so execute sequentially */
                for (int y = 0; y < height; y = y+1) {
                    for (int x = 0; x < __omp_vars.width; x++) {
                        int pixel = __omp_vars.newBitmap.getPixel(x, y);
                        Color.colorToHSV(pixel, __omp_vars.hsv);
                        __omp_vars.hsv[0] = __omp_vars._hue;
                        __omp_vars.newBitmap.setPixel(x, y, Color.HSVToColor(Color.alpha(pixel), __omp_vars.hsv));
                    }
                }
            }

        }
//#GEN#[-1]#PJ#
        __omp_vars.bitmap = bitmap; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.hue = hue; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.width = width; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.height = height; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars._hue = _hue; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.hsv = hsv; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.newBitmap = newBitmap; // restore auto-saved variable//#GEN#[-1]#PJ#
    }
    public static Bitmap tint(Bitmap src, int color) {{
        int width = src.getWidth();
        int height = src.getHeight();
        Bitmap bmOut = Bitmap.createBitmap(width, height, src.getConfig());
        Paint p = new Paint(Color.RED);
        ColorFilter filter = new LightingColorFilter(color, 1);
        p.setColorFilter(filter);
        Canvas c = new Canvas();
        c.setBitmap(bmOut);
        c.drawBitmap(src, 0, 0, p);
        src.recycle();
        src = null;
        return bmOut;
    }
    }
    
    public static Bitmap invert(Bitmap src) {{
        Bitmap output = Bitmap.createBitmap(src.getWidth(), src.getHeight(), src.getConfig());
        int A = 0, R = 0, G = 0, B = 0;
        int pixelColor = 0;
        int height = src.getHeight();
        int width = src.getWidth();
        /*OpenMP Parallel region (#27) -- START */
        if(Pyjama.insideParallelRegion() ) {
            /* If already inside a parallel region, execute sequentially (nested parallelism currently not supported) */
            {
                for (int y = 0; y < height; y = y+1) {
                    for (int x = 0; x < width; x++) {
                        pixelColor = src.getPixel(x, y);
                        A = Color.alpha(pixelColor);
                        R = 255 - Color.red(pixelColor);
                        G = 255 - Color.green(pixelColor);
                        B = 255 - Color.blue(pixelColor);
                        output.setPixel(x, y, Color.argb(A, R, G, B));
                    }
                }
            }
        } else {
            /* Else, execute in parallel */
            PJPackageOnly.setThreadCountCurrentParallelRegion(Pyjama.omp_get_num_threads());

            /* Process data clauses */
            _omp__parallelRegionVarHolderClass_BitmapProcessing27 _omp__parallelRegionVarHolderInstance_27 = new _omp__parallelRegionVarHolderClass_BitmapProcessing27();
            _omp__parallelRegionVarHolderInstance_27.G = G; // auto-saving
            _omp__parallelRegionVarHolderInstance_27.A = A; // auto-saving
            _omp__parallelRegionVarHolderInstance_27.B = B; // auto-saving
            _omp__parallelRegionVarHolderInstance_27.width = width; // auto-saving
            _omp__parallelRegionVarHolderInstance_27.height = height; // auto-saving
            _omp__parallelRegionVarHolderInstance_27.R = R; // auto-saving
            _omp__parallelRegionVarHolderInstance_27.pixelColor = pixelColor; // auto-saving
            _omp__parallelRegionVarHolderInstance_27.src = src; // auto-saving
            _omp__parallelRegionVarHolderInstance_27.output = output; // auto-saving

            /* Execute using traditional OpenMP (master thread part of the team) */
            PJPackageOnly.setMasterThread(Thread.currentThread());
            TaskID _omp__parallelRegionTaskID_27 = _ompParallelRegion_27(_omp__parallelRegionVarHolderInstance_27);
            __pt___ompParallelRegion_27(_omp__parallelRegionVarHolderInstance_27);
            try {_omp__parallelRegionTaskID_27.waitTillFinished();} catch(Exception __pt__ex) { __pt__ex.printStackTrace(); }
            
            PJPackageOnly.setMasterThread(null);
            _holderForPIFirst.set(true);
//#GEN#[-1]#PJ#
            G=_omp__parallelRegionVarHolderInstance_27.G; // auto-saved//#GEN#[-1]#PJ#
            A=_omp__parallelRegionVarHolderInstance_27.A; // auto-saved//#GEN#[-1]#PJ#
            B=_omp__parallelRegionVarHolderInstance_27.B; // auto-saved//#GEN#[-1]#PJ#
            width=_omp__parallelRegionVarHolderInstance_27.width; // auto-saved//#GEN#[-1]#PJ#
            height=_omp__parallelRegionVarHolderInstance_27.height; // auto-saved//#GEN#[-1]#PJ#
            R=_omp__parallelRegionVarHolderInstance_27.R; // auto-saved//#GEN#[-1]#PJ#
            pixelColor=_omp__parallelRegionVarHolderInstance_27.pixelColor; // auto-saved//#GEN#[-1]#PJ#
            src=_omp__parallelRegionVarHolderInstance_27.src; // auto-saved//#GEN#[-1]#PJ#
            output=_omp__parallelRegionVarHolderInstance_27.output; // auto-saved//#GEN#[-1]#PJ#
            PJPackageOnly.setThreadCountCurrentParallelRegion(1);
        }
        /*OpenMP Parallel region (#27) -- END */

        src.recycle();
        src = null;
        return output;
    }
    }
    static private AtomicBoolean _imFirst_29 = new AtomicBoolean(true);
    static private AtomicInteger _imFinishedCounter_29 = new AtomicInteger(0);
    static private CountDownLatch _waitBarrier_29 = new CountDownLatch(1);
    static private CountDownLatch _waitBarrierAfter_29 = new CountDownLatch(1);
    static private ParIterator<Integer> _pi_29 = null;
    static private Integer _lastElement_29 = null;
    static private _ompWorkSharedUserCode_BitmapProcessing29_variables _ompWorkSharedUserCode_BitmapProcessing29_variables_instance = null;
        static private void _ompWorkSharedUserCode_BitmapProcessing29(_ompWorkSharedUserCode_BitmapProcessing29_variables __omp_vars) {
//#GEN#[-1]#PJ#
        int width = __omp_vars.width; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int height = __omp_vars.height; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int A = __omp_vars.A; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int R = __omp_vars.R; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int G = __omp_vars.G; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int B = __omp_vars.B; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int pixelColor = __omp_vars.pixelColor; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        Bitmap src = __omp_vars.src; // Auto-saved//#GEN#[-1]#PJ#
        Bitmap output = __omp_vars.output; // Auto-saved//#GEN#[-1]#PJ#
        Integer y;
        while (_pi_29.hasNext()) {
            y = _pi_29.next();
            
            {
                for (int x = 0; x < width; x++) {
                    pixelColor = src.getPixel(x, y);
                    A = Color.alpha(pixelColor);
                    R = 255 - Color.red(pixelColor);
                    G = 255 - Color.green(pixelColor);
                    B = 255 - Color.blue(pixelColor);
                    output.setPixel(x, y, Color.argb(A, R, G, B));
                }
            }
        }
//#GEN#[-1]#PJ#
    __omp_vars.src = src; // Re-collected//#GEN#[-1]#PJ#
    __omp_vars.output = output; // Re-collected//#GEN#[-1]#PJ#
    }
    
    
    /* Parallel region, placed in a multi-task */
    TASK(Pyjama.omp_get_num_threads()-1) private static void _ompParallelRegion_27(_omp__parallelRegionVarHolderClass_BitmapProcessing27 __omp_vars) {
//#GEN#[-1]#PJ#
        int G = __omp_vars.G; // Auto-saved//#GEN#[-1]#PJ#
        int A = __omp_vars.A; // Auto-saved//#GEN#[-1]#PJ#
        int B = __omp_vars.B; // Auto-saved//#GEN#[-1]#PJ#
        int width = __omp_vars.width; // Auto-saved//#GEN#[-1]#PJ#
        int height = __omp_vars.height; // Auto-saved//#GEN#[-1]#PJ#
        int R = __omp_vars.R; // Auto-saved//#GEN#[-1]#PJ#
        int pixelColor = __omp_vars.pixelColor; // Auto-saved//#GEN#[-1]#PJ#
        Bitmap src = __omp_vars.src; // Auto-saved//#GEN#[-1]#PJ#
        Bitmap output = __omp_vars.output; // Auto-saved//#GEN#[-1]#PJ#
        {
            if ( Pyjama.insideParallelRegion() ) {
                /* Share the following work-sharing construct amongst multiple threads only if inside a parallel region (need this check for orphaned work-sharing constructs) */
                boolean _omp_imFirst = _imFirst_29.getAndSet(false);
                _holderForPIFirst = _imFirst_29;
                if (_omp_imFirst) {
                    _ompWorkSharedUserCode_BitmapProcessing29_variables_instance = new _ompWorkSharedUserCode_BitmapProcessing29_variables();
                    int __omp_size_ = 0;
                    // TODO -- improve performance by calculating N from the parameters (as an equation) rather than looping
                    for (int y = 0; y < height; y = y+1) {
                        _lastElement_29 = y;
                        __omp_size_++;
                        }
                    _pi_29 = ParIteratorFactory.createParIterator(0, __omp_size_, 1, Pyjama.omp_get_num_threads(), ParIterator.Schedule.DYNAMIC, 10, false);
                    _omp_piVarContainer.add(_pi_29); // for interrupt statement
                    _pi_29.setThreadIdGenerator(new UniqueThreadIdGeneratorForOpenMP());//#GEN#[-1]#PJ#
//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing29_variables_instance.width = width; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing29_variables_instance.height = height; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing29_variables_instance.A = A; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing29_variables_instance.R = R; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing29_variables_instance.G = G; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing29_variables_instance.B = B; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing29_variables_instance.pixelColor = pixelColor; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing29_variables_instance.src = src; // auto-saving
                    _ompWorkSharedUserCode_BitmapProcessing29_variables_instance.output = output; // auto-saving
                    _waitBarrier_29.countDown();
                } else {
                    try { _waitBarrier_29.await(); } catch (InterruptedException __omp__ie) { __omp__ie.printStackTrace(); }
                }
                _ompWorkSharedUserCode_BitmapProcessing29(_ompWorkSharedUserCode_BitmapProcessing29_variables_instance);
                if (_imFinishedCounter_29.incrementAndGet() == PJPackageOnly.getThreadCountCurrentParallelRegion()) {
                    _waitBarrierAfter_29.countDown();
                } else {
                    try { 
                        _waitBarrierAfter_29.await();
                    } catch (InterruptedException __omp__ie) { 
                        __omp__ie.printStackTrace(); 
                    }
                }
                // TODO: recollect
//#GEN#[-1]#PJ#
            } else {
                /* Otherwise, this orphaned work-sharing is not within a parallel region.. so execute sequentially */
                for (int y = 0; y < height; y = y+1) {
                    for (int x = 0; x < __omp_vars.width; x++) {
                        __omp_vars.pixelColor = __omp_vars.src.getPixel(x, y);
                        __omp_vars.A = Color.alpha(__omp_vars.pixelColor);
                        __omp_vars.R = 255 - Color.red(__omp_vars.pixelColor);
                        __omp_vars.G = 255 - Color.green(__omp_vars.pixelColor);
                        __omp_vars.B = 255 - Color.blue(__omp_vars.pixelColor);
                        __omp_vars.output.setPixel(x, y, Color.argb(__omp_vars.A, __omp_vars.R, __omp_vars.G, __omp_vars.B));
                    }
                }
            }

        }
//#GEN#[-1]#PJ#
        __omp_vars.G = G; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.A = A; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.B = B; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.width = width; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.height = height; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.R = R; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.pixelColor = pixelColor; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.src = src; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.output = output; // restore auto-saved variable//#GEN#[-1]#PJ#
    }
    public static Bitmap boost(Bitmap src, int type, float percent) {{
        percent = (float) percent / 100;
        int width = src.getWidth();
        int height = src.getHeight();
        Bitmap bmOut = Bitmap.createBitmap(width, height, src.getConfig());
        int A = 0, R = 0, G = 0, B = 0;
        int pixel = 0;
        /*OpenMP Parallel region (#30) -- START */
        if(Pyjama.insideParallelRegion() ) {
            /* If already inside a parallel region, execute sequentially (nested parallelism currently not supported) */
            {
                for (int x = 0; x < width; x = x+1) {
                    for (int y = 0; y < height; ++y) {
                        pixel = src.getPixel(x, y);
                        A = Color.alpha(pixel);
                        R = Color.red(pixel);
                        G = Color.green(pixel);
                        B = Color.blue(pixel);
                        if (type == 1) {
                            R = (int) (R * (1 + percent));
                            if (R > 255) R = 255;
                        } else if (type == 2) {
                            G = (int) (G * (1 + percent));
                            if (G > 255) G = 255;
                        } else if (type == 3) {
                            B = (int) (B * (1 + percent));
                            if (B > 255) B = 255;
                        }
                        bmOut.setPixel(x, y, Color.argb(A, R, G, B));
                    }
                }
            }
        } else {
            /* Else, execute in parallel */
            PJPackageOnly.setThreadCountCurrentParallelRegion(Pyjama.omp_get_num_threads());

            /* Process data clauses */
            _omp__parallelRegionVarHolderClass_BitmapProcessing30 _omp__parallelRegionVarHolderInstance_30 = new _omp__parallelRegionVarHolderClass_BitmapProcessing30();
            _omp__parallelRegionVarHolderInstance_30.G = G; // auto-saving
            _omp__parallelRegionVarHolderInstance_30.percent = percent; // auto-saving
            _omp__parallelRegionVarHolderInstance_30.pixel = pixel; // auto-saving
            _omp__parallelRegionVarHolderInstance_30.A = A; // auto-saving
            _omp__parallelRegionVarHolderInstance_30.B = B; // auto-saving
            _omp__parallelRegionVarHolderInstance_30.width = width; // auto-saving
            _omp__parallelRegionVarHolderInstance_30.type = type; // auto-saving
            _omp__parallelRegionVarHolderInstance_30.bmOut = bmOut; // auto-saving
            _omp__parallelRegionVarHolderInstance_30.height = height; // auto-saving
            _omp__parallelRegionVarHolderInstance_30.R = R; // auto-saving
            _omp__parallelRegionVarHolderInstance_30.src = src; // auto-saving

            /* Execute using traditional OpenMP (master thread part of the team) */
            PJPackageOnly.setMasterThread(Thread.currentThread());
            TaskID _omp__parallelRegionTaskID_30 = _ompParallelRegion_30(_omp__parallelRegionVarHolderInstance_30);
            __pt___ompParallelRegion_30(_omp__parallelRegionVarHolderInstance_30);
            try {_omp__parallelRegionTaskID_30.waitTillFinished();} catch(Exception __pt__ex) { __pt__ex.printStackTrace(); }
            
            PJPackageOnly.setMasterThread(null);
            _holderForPIFirst.set(true);
//#GEN#[-1]#PJ#
            G=_omp__parallelRegionVarHolderInstance_30.G; // auto-saved//#GEN#[-1]#PJ#
            percent=_omp__parallelRegionVarHolderInstance_30.percent; // auto-saved//#GEN#[-1]#PJ#
            pixel=_omp__parallelRegionVarHolderInstance_30.pixel; // auto-saved//#GEN#[-1]#PJ#
            A=_omp__parallelRegionVarHolderInstance_30.A; // auto-saved//#GEN#[-1]#PJ#
            B=_omp__parallelRegionVarHolderInstance_30.B; // auto-saved//#GEN#[-1]#PJ#
            width=_omp__parallelRegionVarHolderInstance_30.width; // auto-saved//#GEN#[-1]#PJ#
            type=_omp__parallelRegionVarHolderInstance_30.type; // auto-saved//#GEN#[-1]#PJ#
            bmOut=_omp__parallelRegionVarHolderInstance_30.bmOut; // auto-saved//#GEN#[-1]#PJ#
            height=_omp__parallelRegionVarHolderInstance_30.height; // auto-saved//#GEN#[-1]#PJ#
            R=_omp__parallelRegionVarHolderInstance_30.R; // auto-saved//#GEN#[-1]#PJ#
            src=_omp__parallelRegionVarHolderInstance_30.src; // auto-saved//#GEN#[-1]#PJ#
            PJPackageOnly.setThreadCountCurrentParallelRegion(1);
        }
        /*OpenMP Parallel region (#30) -- END */

        src.recycle();
        src = null;
        return bmOut;
    }
    }
    static private AtomicBoolean _imFirst_32 = new AtomicBoolean(true);
    static private AtomicInteger _imFinishedCounter_32 = new AtomicInteger(0);
    static private CountDownLatch _waitBarrier_32 = new CountDownLatch(1);
    static private CountDownLatch _waitBarrierAfter_32 = new CountDownLatch(1);
    static private ParIterator<Integer> _pi_32 = null;
    static private Integer _lastElement_32 = null;
    static private _ompWorkSharedUserCode_BitmapProcessing32_variables _ompWorkSharedUserCode_BitmapProcessing32_variables_instance = null;
        static private void _ompWorkSharedUserCode_BitmapProcessing32(_ompWorkSharedUserCode_BitmapProcessing32_variables __omp_vars) {
//#GEN#[-1]#PJ#
        int width = __omp_vars.width; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int height = __omp_vars.height; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int A = __omp_vars.A; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int R = __omp_vars.R; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int G = __omp_vars.G; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int B = __omp_vars.B; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int pixel = __omp_vars.pixel; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        int type = __omp_vars.type; // Shared-var: Auto Saving//#GEN#[-1]#PJ#
        float percent = __omp_vars.percent; // Auto-saved//#GEN#[-1]#PJ#
        Bitmap bmOut = __omp_vars.bmOut; // Auto-saved//#GEN#[-1]#PJ#
        Bitmap src = __omp_vars.src; // Auto-saved//#GEN#[-1]#PJ#
        Integer x;
        while (_pi_32.hasNext()) {
            x = _pi_32.next();
            
            {
                for (int y = 0; y < height; ++y) {
                    pixel = src.getPixel(x, y);
                    A = Color.alpha(pixel);
                    R = Color.red(pixel);
                    G = Color.green(pixel);
                    B = Color.blue(pixel);
                    if (type == 1) {
                        R = (int) (R * (1 + percent));
                        if (R > 255) R = 255;
                    } else if (type == 2) {
                        G = (int) (G * (1 + percent));
                        if (G > 255) G = 255;
                    } else if (type == 3) {
                        B = (int) (B * (1 + percent));
                        if (B > 255) B = 255;
                    }
                    bmOut.setPixel(x, y, Color.argb(A, R, G, B));
                }
            }
        }
//#GEN#[-1]#PJ#
    __omp_vars.percent = percent; // Re-collected//#GEN#[-1]#PJ#
    __omp_vars.bmOut = bmOut; // Re-collected//#GEN#[-1]#PJ#
    __omp_vars.src = src; // Re-collected//#GEN#[-1]#PJ#
    }
    
    
    /* Parallel region, placed in a multi-task */
    TASK(Pyjama.omp_get_num_threads()-1) private static void _ompParallelRegion_30(_omp__parallelRegionVarHolderClass_BitmapProcessing30 __omp_vars) {
//#GEN#[-1]#PJ#
        int G = __omp_vars.G; // Auto-saved//#GEN#[-1]#PJ#
        float percent = __omp_vars.percent; // Auto-saved//#GEN#[-1]#PJ#
        int pixel = __omp_vars.pixel; // Auto-saved//#GEN#[-1]#PJ#
        int A = __omp_vars.A; // Auto-saved//#GEN#[-1]#PJ#
        int B = __omp_vars.B; // Auto-saved//#GEN#[-1]#PJ#
        int width = __omp_vars.width; // Auto-saved//#GEN#[-1]#PJ#
        int type = __omp_vars.type; // Auto-saved//#GEN#[-1]#PJ#
        Bitmap bmOut = __omp_vars.bmOut; // Auto-saved//#GEN#[-1]#PJ#
        int height = __omp_vars.height; // Auto-saved//#GEN#[-1]#PJ#
        int R = __omp_vars.R; // Auto-saved//#GEN#[-1]#PJ#
        Bitmap src = __omp_vars.src; // Auto-saved//#GEN#[-1]#PJ#
        {
            if ( Pyjama.insideParallelRegion() ) {
                /* Share the following work-sharing construct amongst multiple threads only if inside a parallel region (need this check for orphaned work-sharing constructs) */
                boolean _omp_imFirst = _imFirst_32.getAndSet(false);
                _holderForPIFirst = _imFirst_32;
                if (_omp_imFirst) {
                    _ompWorkSharedUserCode_BitmapProcessing32_variables_instance = new _ompWorkSharedUserCode_BitmapProcessing32_variables();
                    int __omp_size_ = 0;
                    // TODO -- improve performance by calculating N from the parameters (as an equation) rather than looping
                    for (int x = 0; x < width; x = x+1) {
                        _lastElement_32 = x;
                        __omp_size_++;
                        }
                    _pi_32 = ParIteratorFactory.createParIterator(0, __omp_size_, 1, Pyjama.omp_get_num_threads(), ParIterator.Schedule.DYNAMIC, 10, false);
                    _omp_piVarContainer.add(_pi_32); // for interrupt statement
                    _pi_32.setThreadIdGenerator(new UniqueThreadIdGeneratorForOpenMP());//#GEN#[-1]#PJ#
//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing32_variables_instance.width = width; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing32_variables_instance.height = height; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing32_variables_instance.A = A; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing32_variables_instance.R = R; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing32_variables_instance.G = G; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing32_variables_instance.B = B; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing32_variables_instance.pixel = pixel; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing32_variables_instance.type = type; // shared: copying to workshares//#GEN#[-1]#PJ#
                    _ompWorkSharedUserCode_BitmapProcessing32_variables_instance.percent = percent; // auto-saving
                    _ompWorkSharedUserCode_BitmapProcessing32_variables_instance.bmOut = bmOut; // auto-saving
                    _ompWorkSharedUserCode_BitmapProcessing32_variables_instance.src = src; // auto-saving
                    _waitBarrier_32.countDown();
                } else {
                    try { _waitBarrier_32.await(); } catch (InterruptedException __omp__ie) { __omp__ie.printStackTrace(); }
                }
                _ompWorkSharedUserCode_BitmapProcessing32(_ompWorkSharedUserCode_BitmapProcessing32_variables_instance);
                if (_imFinishedCounter_32.incrementAndGet() == PJPackageOnly.getThreadCountCurrentParallelRegion()) {
                    _waitBarrierAfter_32.countDown();
                } else {
                    try { 
                        _waitBarrierAfter_32.await();
                    } catch (InterruptedException __omp__ie) { 
                        __omp__ie.printStackTrace(); 
                    }
                }
                // TODO: recollect
//#GEN#[-1]#PJ#
            } else {
                /* Otherwise, this orphaned work-sharing is not within a parallel region.. so execute sequentially */
                for (int x = 0; x < width; x = x+1) {
                    for (int y = 0; y < __omp_vars.height; ++y) {
                        __omp_vars.pixel = __omp_vars.src.getPixel(x, y);
                        __omp_vars.A = Color.alpha(__omp_vars.pixel);
                        __omp_vars.R = Color.red(__omp_vars.pixel);
                        __omp_vars.G = Color.green(__omp_vars.pixel);
                        __omp_vars.B = Color.blue(__omp_vars.pixel);
                        if (__omp_vars.type == 1) {
                            __omp_vars.R = (int) (__omp_vars.R * (1 + __omp_vars.percent));
                            if (__omp_vars.R > 255) __omp_vars.R = 255;
                        } else if (__omp_vars.type == 2) {
                            __omp_vars.G = (int) (__omp_vars.G * (1 + __omp_vars.percent));
                            if (__omp_vars.G > 255) __omp_vars.G = 255;
                        } else if (__omp_vars.type == 3) {
                            __omp_vars.B = (int) (__omp_vars.B * (1 + __omp_vars.percent));
                            if (__omp_vars.B > 255) __omp_vars.B = 255;
                        }
                        __omp_vars.bmOut.setPixel(x, y, Color.argb(__omp_vars.A, __omp_vars.R, __omp_vars.G, __omp_vars.B));
                    }
                }
            }

        }
//#GEN#[-1]#PJ#
        __omp_vars.G = G; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.percent = percent; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.pixel = pixel; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.A = A; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.B = B; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.width = width; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.type = type; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.bmOut = bmOut; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.height = height; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.R = R; // restore auto-saved variable//#GEN#[-1]#PJ#
        __omp_vars.src = src; // restore auto-saved variable//#GEN#[-1]#PJ#
    }
    public static final Bitmap sketch(Bitmap src) {{
        int type = 6;
        int threshold = 130;
        int width = src.getWidth();
        int height = src.getHeight();
        Bitmap result = Bitmap.createBitmap(width, height, src.getConfig());
        int A = 0, R = 0, G = 0, B = 0;
        int sumR = 0, sumG = 0, sumB = 0;
        int[][] pixels = new int[3][3];
        for (int y = 0; y < height - 2; ++y) {
            for (int x = 0; x < width - 2; ++x) {
                for (int i = 0; i < 3; ++i) {
                    for (int j = 0; j < 3; ++j) {
                        pixels[i][j] = src.getPixel(x + i, y + j);
                    }
                }
                A = Color.alpha(pixels[1][1]);
                sumR = sumG = sumB = 0;
                sumR = (type * Color.red(pixels[1][1])) - Color.red(pixels[0][0]) - Color.red(pixels[0][2]) - Color.red(pixels[2][0]) - Color.red(pixels[2][2]);
                sumG = (type * Color.green(pixels[1][1])) - Color.green(pixels[0][0]) - Color.green(pixels[0][2]) - Color.green(pixels[2][0]) - Color.green(pixels[2][2]);
                sumB = (type * Color.blue(pixels[1][1])) - Color.blue(pixels[0][0]) - Color.blue(pixels[0][2]) - Color.blue(pixels[2][0]) - Color.blue(pixels[2][2]);
                R = (int) (sumR + threshold);
                if (R < 0) {
                    R = 0;
                } else if (R > 255) {
                    R = 255;
                }
                G = (int) (sumG + threshold);
                if (G < 0) {
                    G = 0;
                } else if (G > 255) {
                    G = 255;
                }
                B = (int) (sumB + threshold);
                if (B < 0) {
                    B = 0;
                } else if (B > 255) {
                    B = 255;
                }
                result.setPixel(x + 1, y + 1, Color.argb(A, R, G, B));
            }
        }
        src.recycle();
        src = null;
        return result;
    }
    }
    
    public static Bitmap modifyOrientation(Bitmap bitmap, String image_url) throws IOException {{
        ExifInterface ei = new ExifInterface(image_url);
        int orientation = ei.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL);
        switch(orientation) {
            case ExifInterface.ORIENTATION_ROTATE_90:
                return rotate(bitmap, 90);
            case ExifInterface.ORIENTATION_ROTATE_180:
                return rotate(bitmap, 180);
            case ExifInterface.ORIENTATION_ROTATE_270:
                return rotate(bitmap, 270);
            case ExifInterface.ORIENTATION_FLIP_HORIZONTAL:
                return flip(bitmap, true, false);
            case ExifInterface.ORIENTATION_FLIP_VERTICAL:
                return flip(bitmap, false, true);
            default:
                return bitmap;
        }
    }
    }
    
}
